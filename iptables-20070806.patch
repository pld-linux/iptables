diff -urN iptables-1.3.8/extensions/.ACCOUNT-test iptables/extensions/.ACCOUNT-test
--- iptables-1.3.8/extensions/.ACCOUNT-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.ACCOUNT-test	2007-02-13 15:42:46.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if ACCOUNT is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_ACCOUNT.h ] && echo ACCOUNT
diff -urN iptables-1.3.8/extensions/.IPMARK-test iptables/extensions/.IPMARK-test
--- iptables-1.3.8/extensions/.IPMARK-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.IPMARK-test	2006-12-04 12:15:19.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IPMARK patch is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_IPMARK.h ] && echo IPMARK
diff -urN iptables-1.3.8/extensions/.IPV4OPTSSTRIP-test iptables/extensions/.IPV4OPTSSTRIP-test
--- iptables-1.3.8/extensions/.IPV4OPTSSTRIP-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.IPV4OPTSSTRIP-test	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if IPV4OPTSSTRIP patch is applied.
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_IPV4OPTSSTRIP.c ] && echo IPV4OPTSSTRIP
diff -urN iptables-1.3.8/extensions/.TARPIT-test iptables/extensions/.TARPIT-test
--- iptables-1.3.8/extensions/.TARPIT-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.TARPIT-test	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv4/netfilter/ipt_TARPIT.c ] && echo TARPIT
diff -urN iptables-1.3.8/extensions/.connlimit-test iptables/extensions/.connlimit-test
--- iptables-1.3.8/extensions/.connlimit-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.connlimit-test	2007-03-07 13:26:10.000000000 +0100
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_connlimit.h ] && echo connlimit
diff -urN iptables-1.3.8/extensions/.geoip-test iptables/extensions/.geoip-test
--- iptables-1.3.8/extensions/.geoip-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.geoip-test	2006-05-06 13:18:20.000000000 +0200
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if geoip is applied in given kernel tree.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_geoip.h ] && echo geoip
diff -urN iptables-1.3.8/extensions/.ipp2p-test iptables/extensions/.ipp2p-test
--- iptables-1.3.8/extensions/.ipp2p-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.ipp2p-test	2004-07-13 13:43:15.000000000 +0200
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_ipp2p.h ] && echo ipp2p
diff -urN iptables-1.3.8/extensions/.ipv4options-test iptables/extensions/.ipv4options-test
--- iptables-1.3.8/extensions/.ipv4options-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.ipv4options-test	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if ipv4options is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_ipv4options.h ] && echo ipv4options
diff -urN iptables-1.3.8/extensions/.time-test iptables/extensions/.time-test
--- iptables-1.3.8/extensions/.time-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.time-test	2006-12-04 12:15:20.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if time is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_time.h ] && echo time
diff -urN iptables-1.3.8/extensions/.u32-test iptables/extensions/.u32-test
--- iptables-1.3.8/extensions/.u32-test	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/.u32-test	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,3 @@
+#!/bin/sh
+# True if u32 is applied.
+[ -f $KERNEL_DIR/include/linux/netfilter_ipv4/ipt_u32.h ] && echo u32
diff -urN iptables-1.3.8/extensions/libipt_ACCOUNT.c iptables/extensions/libipt_ACCOUNT.c
--- iptables-1.3.8/extensions/libipt_ACCOUNT.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_ACCOUNT.c	2006-10-26 12:17:57.000000000 +0200
@@ -0,0 +1,174 @@
+/* Shared library add-on to iptables to add ACCOUNT(ing) support.
+   Author: Intra2net AG <opensource@intra2net.com>
+*/
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <syslog.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_ACCOUNT.h>
+
+static struct option opts[] = {
+    { .name = "addr",        .has_arg = 1, .flag = 0, .val = 'a' },
+    { .name = "tname",       .has_arg = 1, .flag = 0, .val = 't' },
+    { .name = 0 }
+};
+
+/* Function which prints out usage message. */
+static void help(void)
+{
+    printf(
+"ACCOUNT v%s options:\n"
+" --%s ip/netmask\t\tBase network IP and netmask used for this table\n"
+" --%s name\t\t\tTable name for the userspace library\n",
+IPTABLES_VERSION, opts[0].name, opts[1].name);
+}
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+    struct ipt_acc_info *accountinfo = (struct ipt_acc_info *)t->data;
+
+    accountinfo->table_nr = -1;
+
+    /* Can't cache this */
+    *nfcache |= NFC_UNKNOWN;
+}
+
+#define IPT_ACCOUNT_OPT_ADDR 0x01
+#define IPT_ACCOUNT_OPT_TABLE 0x02
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+    struct ipt_acc_info *accountinfo = (struct ipt_acc_info *)(*target)->data;
+    struct in_addr *addrs = NULL, mask;
+    unsigned int naddrs = 0;
+
+    switch (c) {
+    case 'a':
+        if (*flags & IPT_ACCOUNT_OPT_ADDR)
+                exit_error(PARAMETER_PROBLEM, "Can't specify --%s twice",
+                            opts[0].name);
+
+        if (check_inverse(optarg, &invert, NULL, 0))
+                exit_error(PARAMETER_PROBLEM, "Unexpected `!' after --%s",
+                            opts[0].name);
+
+        //loginfo->level = parse_level(optarg);
+        parse_hostnetworkmask(optarg, &addrs, &mask, &naddrs);
+        
+        if (naddrs > 1)
+                exit_error(PARAMETER_PROBLEM, "multiple IP addresses not allowed");
+        
+        accountinfo->net_ip = addrs[0].s_addr;
+        accountinfo->net_mask = mask.s_addr;
+                
+        *flags |= IPT_ACCOUNT_OPT_ADDR;
+        break;
+
+    case 't':
+            if (*flags & IPT_ACCOUNT_OPT_TABLE)
+                    exit_error(PARAMETER_PROBLEM,
+                                "Can't specify --%s twice", opts[1].name);
+
+            if (check_inverse(optarg, &invert, NULL, 0))
+                    exit_error(PARAMETER_PROBLEM,
+                                "Unexpected `!' after --%s", opts[1].name);
+
+            if (strlen(optarg) > ACCOUNT_TABLE_NAME_LEN - 1)
+                    exit_error(PARAMETER_PROBLEM,
+                                "Maximum table name length %u for --%s",
+                                ACCOUNT_TABLE_NAME_LEN - 1, opts[1].name);
+
+            strcpy(accountinfo->table_name, optarg);
+            *flags |= IPT_ACCOUNT_OPT_TABLE;
+            break;
+    
+    default:
+            return 0;
+    }
+    return 1;
+}
+
+/* Final check; nothing. */
+static void final_check(unsigned int flags)
+{
+    if (!(flags&IPT_ACCOUNT_OPT_ADDR) || !(flags&IPT_ACCOUNT_OPT_TABLE))
+        exit_error(PARAMETER_PROBLEM, "ACCOUNT: needs --%s and --%s",
+                    opts[0].name, opts[1].name);
+}
+
+static void print_it(const struct ipt_ip *ip,
+                     const struct ipt_entry_target *target, char do_prefix)
+{
+    const struct ipt_acc_info *accountinfo
+        = (const struct ipt_acc_info *)target->data;
+    struct in_addr a;
+
+    if (!do_prefix)
+        printf("ACCOUNT ");
+    
+    // Network information
+    if (do_prefix)
+	printf("--");
+    printf("%s ", opts[0].name);
+    
+    a.s_addr = accountinfo->net_ip;	
+    printf("%s", addr_to_dotted(&a));
+    a.s_addr = accountinfo->net_mask;
+    printf("%s", mask_to_dotted(&a));
+
+    printf(" ");
+    if (do_prefix)
+	printf("--");
+
+    printf("%s %s", opts[1].name, accountinfo->table_name);
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+    print_it (ip, target, 0);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+    print_it(ip, target, 1);
+}
+
+static
+struct iptables_target account
+= {
+    .next          = NULL,
+    .name          = "ACCOUNT",
+    .version       = IPTABLES_VERSION,
+    .size          = IPT_ALIGN(sizeof(struct ipt_acc_info)),
+    .userspacesize = IPT_ALIGN(sizeof(struct ipt_acc_info)),
+    .help          = &help,
+    .init          = &init,
+    .parse         = &parse,
+    .final_check   = &final_check,
+    .print         = &print,
+    .save          = &save,
+    .extra_opts    = opts
+};
+
+void _init(void)
+{
+    register_target(&account);
+}
diff -urN iptables-1.3.8/extensions/libipt_IPMARK.c iptables/extensions/libipt_IPMARK.c
--- iptables-1.3.8/extensions/libipt_IPMARK.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_IPMARK.c	2006-12-04 12:15:20.000000000 +0100
@@ -0,0 +1,168 @@
+/* Shared library add-on to iptables to add IPMARK target support.
+ * (C) 2003 by Grzegorz Janoszka <Grzegorz.Janoszka@pro.onet.pl>
+ *
+ * based on original MARK target
+ * 
+ * This program is distributed under the terms of GNU GPL
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_ipv4/ipt_IPMARK.h>
+
+#define IPT_ADDR_USED        1
+#define IPT_AND_MASK_USED    2
+#define IPT_OR_MASK_USED     4
+
+struct ipmarkinfo {
+	struct ipt_entry_target t;
+	struct ipt_ipmark_target_info ipmark;
+};
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"IPMARK target v%s options:\n"
+"  --addr src/dst         use source or destination ip address\n"
+"  --and-mask value       logical AND ip address with this value becomes MARK\n"
+"  --or-mask value        logical OR ip address with this value becomes MARK\n"
+"\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "addr", 1, 0, '1' },
+	{ "and-mask", 1, 0, '2' },
+	{ "or-mask", 1, 0, '3' },
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ipt_entry_target *t, unsigned int *nfcache)
+{
+	struct ipt_ipmark_target_info *ipmarkinfo =
+		(struct ipt_ipmark_target_info *)t->data;
+
+	ipmarkinfo->andmask=0xffffffff;
+	ipmarkinfo->ormask=0;
+
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	struct ipt_ipmark_target_info *ipmarkinfo
+		= (struct ipt_ipmark_target_info *)(*target)->data;
+
+	switch (c) {
+		char *end;
+	case '1':
+		if(!strcmp(optarg, "src")) ipmarkinfo->addr=IPT_IPMARK_SRC;
+		  else if(!strcmp(optarg, "dst")) ipmarkinfo->addr=IPT_IPMARK_DST;
+		    else exit_error(PARAMETER_PROBLEM, "Bad addr value `%s' - should be `src' or `dst'", optarg);
+		if (*flags & IPT_ADDR_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --addr twice");
+		*flags |= IPT_ADDR_USED;
+		break;
+	
+	case '2':
+		ipmarkinfo->andmask = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad and-mask value `%s'", optarg);
+		if (*flags & IPT_AND_MASK_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --and-mask twice");
+		*flags |= IPT_AND_MASK_USED;
+		break;
+	case '3':
+		ipmarkinfo->ormask = strtoul(optarg, &end, 0);
+		if (*end != '\0' || end == optarg)
+			exit_error(PARAMETER_PROBLEM, "Bad or-mask value `%s'", optarg);
+		if (*flags & IPT_OR_MASK_USED)
+			exit_error(PARAMETER_PROBLEM,
+			           "IPMARK target: Can't specify --or-mask twice");
+		*flags |= IPT_OR_MASK_USED;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (!(flags & IPT_ADDR_USED))
+		exit_error(PARAMETER_PROBLEM,
+		           "IPMARK target: Parameter --addr is required");
+	if (!(flags & (IPT_AND_MASK_USED | IPT_OR_MASK_USED)))
+		exit_error(PARAMETER_PROBLEM,
+		           "IPMARK target: Parameter --and-mask or --or-mask is required");
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	const struct ipt_ipmark_target_info *ipmarkinfo =
+		(const struct ipt_ipmark_target_info *)target->data;
+
+	if(ipmarkinfo->addr == IPT_IPMARK_SRC)
+	  printf("IPMARK src");
+	else
+	  printf("IPMARK dst");
+	printf(" ip and 0x%lx or 0x%lx", ipmarkinfo->andmask, ipmarkinfo->ormask);
+}
+
+/* Saves the union ipt_targinfo in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	const struct ipt_ipmark_target_info *ipmarkinfo =
+		(const struct ipt_ipmark_target_info *)target->data;
+
+	if(ipmarkinfo->addr == IPT_IPMARK_SRC)
+	  printf("--addr=src ");
+	else
+	  printf("--addr=dst ");
+	if(ipmarkinfo->andmask != 0xffffffff)
+	  printf("--and-mask 0x%lx ", ipmarkinfo->andmask);
+	if(ipmarkinfo->ormask != 0)
+	  printf("--or-mask 0x%lx ", ipmarkinfo->ormask);
+}
+
+static struct iptables_target ipmark = { 
+	.next		= NULL,
+	.name		= "IPMARK",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ipmark_target_info)),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&ipmark);
+}
diff -urN iptables-1.3.8/extensions/libipt_IPMARK.man iptables/extensions/libipt_IPMARK.man
--- iptables-1.3.8/extensions/libipt_IPMARK.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_IPMARK.man	2006-12-04 12:15:19.000000000 +0100
@@ -0,0 +1,45 @@
+Allows you to mark a received packet basing on its IP address. This
+can replace many mangle/mark entries with only one, if you use
+firewall based classifier.
+
+This target is to be used inside the mangle table, in the PREROUTING,
+POSTROUTING or FORWARD hooks.
+.TP
+.BI "--addr " "src/dst"
+Use source or destination IP address.
+.TP
+.BI "--and-mask " "mask"
+Perform bitwise `and' on the IP address and this mask.
+.TP
+.BI "--or-mask " "mask"
+Perform bitwise `or' on the IP address and this mask.
+.P
+The order of IP address bytes is reversed to meet "human order of bytes":
+192.168.0.1 is 0xc0a80001. At first the `and' operation is performed, then
+`or'.
+
+Examples:
+
+We create a queue for each user, the queue number is adequate
+to the IP address of the user, e.g.: all packets going to/from 192.168.5.2
+are directed to 1:0502 queue, 192.168.5.12 -> 1:050c etc.
+
+We have one classifier rule:
+.IP
+tc filter add dev eth3 parent 1:0 protocol ip fw
+.P
+Earlier we had many rules just like below:
+.IP
+iptables -t mangle -A POSTROUTING -o eth3 -d 192.168.5.2 -j MARK
+--set-mark 0x10502
+.IP
+iptables -t mangle -A POSTROUTING -o eth3 -d 192.168.5.3 -j MARK
+--set-mark 0x10503
+.P
+Using IPMARK target we can replace all the mangle/mark rules with only one:
+.IP
+iptables -t mangle -A POSTROUTING -o eth3 -j IPMARK --addr=dst
+--and-mask=0xffff --or-mask=0x10000
+.P
+On the routers with hundreds of users there should be significant load
+decrease (e.g. twice).
diff -urN iptables-1.3.8/extensions/libipt_IPV4OPTSSTRIP.c iptables/extensions/libipt_IPV4OPTSSTRIP.c
--- iptables-1.3.8/extensions/libipt_IPV4OPTSSTRIP.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_IPV4OPTSSTRIP.c	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,74 @@
+/* Shared library add-on to iptables for IPV4OPTSSTRIP
+ * This modules strip all the IP options.
+ *
+ * (C) 2001 by Fabrice MARIE <fabrice@netfilter.org>
+ * This program is distributed under the terms of GNU GPL v2, 1991
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ip_tables.h>
+
+static void help(void) 
+{
+	printf("IPV4OPTSSTRIP v%s target takes no option !! Make sure you use it in the mangle table.\n",
+	       IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+/* Prints out the targinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+	/* nothing to print, we don't take option... */
+}
+
+/* Saves the stuff in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+	/* nothing to print, we don't take option... */
+}
+
+static struct iptables_target IPV4OPTSSTRIP = { 
+	.next		= NULL,
+	.name		= "IPV4OPTSSTRIP",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&IPV4OPTSSTRIP);
+}
diff -urN iptables-1.3.8/extensions/libipt_IPV4OPTSSTRIP.man iptables/extensions/libipt_IPV4OPTSSTRIP.man
--- iptables-1.3.8/extensions/libipt_IPV4OPTSSTRIP.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_IPV4OPTSSTRIP.man	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,5 @@
+Strip all the IP options from a packet.
+
+The target doesn't take any option, and therefore is extremly easy to use :
+
+# iptables -t mangle -A PREROUTING -j IPV4OPTSSTRIP
diff -urN iptables-1.3.8/extensions/libipt_TARPIT.c iptables/extensions/libipt_TARPIT.c
--- iptables-1.3.8/extensions/libipt_TARPIT.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_TARPIT.c	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,58 @@
+/* Shared library add-on to iptables for TARPIT support */
+#include <stdio.h>
+#include <getopt.h>
+#include <iptables.h>
+
+static void
+help(void)
+{
+	fputs(
+"TARPIT takes no options\n"
+"\n", stdout);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      struct ipt_entry_target **target)
+{
+	return 0;
+}
+
+static void final_check(unsigned int flags)
+{
+}
+
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_target *target,
+      int numeric)
+{
+}
+
+static void save(const struct ipt_ip *ip, const struct ipt_entry_target *target)
+{
+}
+
+static struct iptables_target tarpit = {
+	.next		= NULL,
+	.name		= "TARPIT",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(0),
+	.userspacesize	= IPT_ALIGN(0),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_target(&tarpit);
+}
diff -urN iptables-1.3.8/extensions/libipt_TARPIT.man iptables/extensions/libipt_TARPIT.man
--- iptables-1.3.8/extensions/libipt_TARPIT.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_TARPIT.man	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,34 @@
+Captures and holds incoming TCP connections using no local
+per-connection resources. Connections are accepted, but immediately
+switched to the persist state (0 byte window), in which the remote
+side stops sending data and asks to continue every 60-240 seconds.
+Attempts to close the connection are ignored, forcing the remote side
+to time out the connection in 12-24 minutes.
+
+This offers similar functionality to LaBrea
+<http://www.hackbusters.net/LaBrea/> but doesn't require dedicated
+hardware or IPs. Any TCP port that you would normally DROP or REJECT
+can instead become a tarpit.
+
+To tarpit connections to TCP port 80 destined for the current machine:
+.IP
+iptables -A INPUT -p tcp -m tcp --dport 80 -j TARPIT
+.P
+To significantly slow down Code Red/Nimda-style scans of unused address
+space, forward unused ip addresses to a Linux box not acting as a router
+(e.g. "ip route 10.0.0.0 255.0.0.0 ip.of.linux.box" on a Cisco), enable IP
+forwarding on the Linux box, and add:
+.IP
+iptables -A FORWARD -p tcp -j TARPIT
+.IP
+iptables -A FORWARD -j DROP
+.TP
+NOTE:
+If you use the conntrack module while you are using TARPIT, you should
+also use the NOTRACK target, or the kernel will unnecessarily allocate
+resources for each TARPITted connection. To TARPIT incoming
+connections to the standard IRC port while using conntrack, you could:
+.IP
+iptables -t raw -A PREROUTING -p tcp --dport 6667 -j NOTRACK
+.IP
+iptables -A INPUT -p tcp --dport 6667 -j TARPIT
diff -urN iptables-1.3.8/extensions/libipt_connlimit.c iptables/extensions/libipt_connlimit.c
--- iptables-1.3.8/extensions/libipt_connlimit.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_connlimit.c	2006-12-04 12:15:19.000000000 +0100
@@ -0,0 +1,132 @@
+/* Shared library add-on to iptables to add connection limit support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <net/netfilter/nf_conntrack.h>
+#include <linux/netfilter_ipv4/ipt_connlimit.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"connlimit v%s options:\n"
+"[!] --connlimit-above n		match if the number of existing tcp connections is (not) above n\n"
+" --connlimit-mask n		group hosts using mask\n"
+"\n", IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "connlimit-above", 1, 0, '1' },
+	{ "connlimit-mask",  1, 0, '2' },
+	{0}
+};
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)(*match)->data;
+	int i;
+
+	if (0 == (*flags & 2)) {
+		/* set default mask unless we've already seen a mask option */
+		info->mask = htonl(0xFFFFFFFF);
+	}
+
+	switch (c) {
+	case '1':
+		check_inverse(optarg, &invert, &optind, 0);
+		info->limit = atoi(argv[optind-1]);
+		info->inverse = invert;
+		*flags |= 1;
+		break;
+
+	case '2':
+		i = atoi(argv[optind-1]);
+		if ((i < 0) || (i > 32))
+			exit_error(PARAMETER_PROBLEM,
+				"--connlimit-mask must be between 0 and 32");
+
+		if (i == 0)
+			info->mask = 0;
+		else
+			info->mask = htonl(0xFFFFFFFF << (32 - i));
+		*flags |= 2;
+		break;
+
+	default:
+		return 0;
+	}
+
+	return 1;
+}
+
+/* Final check */
+static void final_check(unsigned int flags)
+{
+	if (!flags & 1)
+		exit_error(PARAMETER_PROBLEM, "You must specify `--connlimit-above'");
+}
+
+static int
+count_bits(u_int32_t mask)
+{
+	int i, bits;
+
+	for (bits = 0, i = 31; i >= 0; i--) {
+		if (mask & htonl((u_int32_t)1 << i)) {
+			bits++;
+			continue;
+		}
+		break;
+	}
+	return bits;
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)match->data;
+
+	printf("#conn/%d %s %d ", count_bits(info->mask),
+	       info->inverse ? "<" : ">", info->limit);
+}
+
+/* Saves the matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_connlimit_info *info = (struct ipt_connlimit_info*)match->data;
+
+	printf("%s--connlimit-above %d ",info->inverse ? "! " : "",info->limit);
+	printf("--connlimit-mask %d ",count_bits(info->mask));
+}
+
+static struct iptables_match connlimit = {
+	.name		= "connlimit",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_connlimit_info)),
+	.userspacesize 	= offsetof(struct ipt_connlimit_info,data),
+	.help		= help,
+	.parse 		= parse,
+	.final_check	= final_check,
+	.print		= print,
+	.save		= save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&connlimit);
+}
diff -urN iptables-1.3.8/extensions/libipt_geoip.c iptables/extensions/libipt_geoip.c
--- iptables-1.3.8/extensions/libipt_geoip.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_geoip.c	2006-12-05 04:36:39.000000000 +0100
@@ -0,0 +1,338 @@
+/* Shared library add-on to iptables to add geoip match support.
+ 
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * Copyright (c) 2004, 2005, 2006 Samuel Jean & Nicolas Bouliane
+ 
+ * For comments, bugs or suggestions, please contact
+ * Samuel Jean       <jix at bugmachine.ca>
+ * Nicolas Bouliane  <nib at bugmachine.ca>
+ */
+
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+#include <stddef.h>
+#include <errno.h>
+#include <sys/types.h>
+#include <sys/stat.h>
+#include <unistd.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_geoip.h>
+
+static void help(void)
+{
+   printf (
+            "GeoIP v%s options:\n"
+            "        [!]   --src-cc, --source-country country[,country,country,...]\n"
+            "                                                     Match packet coming from (one of)\n"
+            "                                                     the specified country(ies)\n"
+            "\n"
+            "        [!]   --dst-cc, --destination-country country[,country,country,...]\n"
+            "                                                     Match packet going to (one of)\n"
+            "                                                     the specified country(ies)\n"
+            "\n"
+            "           NOTE: The country is inputed by its ISO3166 code.\n"
+            "\n"
+            "\n", IPTABLES_VERSION
+         );
+}
+
+static struct option opts[] = {
+   {  "dst-cc",  1, 0, '2'  }, /* Alias for --destination-country */
+   {  "destination-country",   1, 0, '2'  },
+   {  "src-cc",  1, 0, '1'  }, /* Alias for --source-country */
+   {  "source-country",  1, 0, '1'  },
+   {  0  }
+};
+
+static void 
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+}
+
+/* NOT IMPLEMENTED YET
+static void geoip_free(struct geoip_info *oldmem)
+{
+}
+*/
+
+struct geoip_index {
+   u_int16_t cc;
+   u_int32_t offset;
+} __attribute__ ((packed));
+
+struct geoip_subnet *
+get_country_subnets(u_int16_t cc, u_int32_t *count)
+{
+   FILE *ixfd, *dbfd;
+   struct geoip_subnet *subnets;
+   struct geoip_index *index;
+   struct stat buf;
+  
+   size_t idxsz;
+   u_int16_t i;
+   
+   u_int16_t db_cc = 0;
+   u_int16_t db_nsubnets = 0;
+
+   if ((ixfd = fopen("/var/geoip/geoipdb.idx", "r")) == NULL) {
+         perror("/var/geoip/geoipdb.idx");
+         exit_error(OTHER_PROBLEM,
+               "geoip match: cannot open geoip's database index file");               
+   }
+   
+   stat("/var/geoip/geoipdb.idx", &buf);
+   idxsz = buf.st_size/sizeof(struct geoip_index);
+   index = (struct geoip_index *)malloc(buf.st_size);
+
+   fread(index, buf.st_size, 1, ixfd);
+
+   for (i = 0; i < idxsz; i++)
+      if (cc == index[i].cc)
+         break;
+   
+   if (cc != index[i].cc)
+      exit_error(OTHER_PROBLEM,
+            "geoip match: sorry, '%c%c' isn't in the database\n", COUNTRY(cc));
+
+   fclose(ixfd);
+
+   if ((dbfd = fopen("/var/geoip/geoipdb.bin", "r")) == NULL) {
+      perror("/var/geoip/geoipdb.bin");
+      exit_error(OTHER_PROBLEM,
+            "geoip match: cannot open geoip's database file");
+   }
+
+   fseek(dbfd, index[i].offset, SEEK_SET);
+   fread(&db_cc, sizeof(u_int16_t), 1, dbfd);
+
+   if (db_cc != cc)
+      exit_error(OTHER_PROBLEM,
+            "geoip match: this shouldn't happened, the database might be corrupted, or there's a bug.\n"
+            "you should contact maintainers");
+            
+   fread(&db_nsubnets, sizeof(u_int16_t), 1, dbfd);
+
+   subnets = (struct geoip_subnet*)malloc(db_nsubnets * sizeof(struct geoip_subnet));
+
+   if (!subnets)
+      exit_error(OTHER_PROBLEM,
+            "geoip match: insufficient memory available");
+   
+   fread(subnets, db_nsubnets * sizeof(struct geoip_subnet), 1, dbfd);
+   
+   fclose(dbfd);
+   free(index);
+   *count = db_nsubnets;
+   return subnets;
+}
+ 
+static struct geoip_info *
+load_geoip_cc(u_int16_t cc)
+{
+   static struct geoip_info *ginfo;
+   ginfo = malloc(sizeof(struct geoip_info));
+
+   if (!ginfo)
+      return NULL;
+   
+   ginfo->subnets = get_country_subnets(cc, &ginfo->count);
+   ginfo->cc = cc;
+   
+   return ginfo;
+}
+
+static u_int16_t
+check_geoip_cc(char *cc, u_int16_t cc_used[], u_int8_t count)
+{
+   u_int8_t i;
+   u_int16_t cc_int16;
+
+   if (strlen(cc) != 2) /* Country must be 2 chars long according
+                                        to the ISO3166 standard */
+    exit_error(PARAMETER_PROBLEM,
+         "geoip match: invalid country code '%s'", cc);
+
+   // Verification will fail if chars aren't uppercased.
+   // Make sure they are..
+   for (i = 0; i < 2; i++)
+      if (isalnum(cc[i]) != 0)
+         cc[i] = toupper(cc[i]);
+      else
+         exit_error(PARAMETER_PROBLEM,
+               "geoip match:  invalid country code '%s'", cc);
+
+   /* Convert chars into a single 16 bit integer.
+    * FIXME:   This assumes that a country code is
+    *          exactly 2 chars long. If this is
+    *          going to change someday, this whole
+    *          match will need to be rewritten, anyway.
+    *                                  - SJ  */
+   cc_int16 = (cc[0]<<8) + cc[1];
+
+   // Check for presence of value in cc_used
+   for (i = 0; i < count; i++)
+      if (cc_int16 == cc_used[i])
+         return 0; // Present, skip it!
+   
+   return cc_int16;
+}
+
+/* Based on libipt_multiport.c parsing code. */ 
+static u_int8_t
+parse_geoip_cc(const char *ccstr, u_int16_t *cc, struct geoip_info **mem)
+{
+   char *buffer, *cp, *next;
+   u_int8_t i, count = 0;
+   u_int16_t cctmp;
+
+   buffer = strdup(ccstr);
+   if (!buffer) exit_error(OTHER_PROBLEM,
+         "geoip match: insufficient memory available");
+
+   for (cp = buffer, i = 0; cp && i < IPT_GEOIP_MAX; cp = next, i++)
+   {
+      next = strchr(cp, ',');
+      if (next) *next++ = '\0';
+      
+      if ((cctmp = check_geoip_cc(cp, cc, count)) != 0) {
+         if ((mem[count++] = load_geoip_cc(cctmp)) == NULL)
+            exit_error(OTHER_PROBLEM,
+                  "geoip match: insufficient memory available");
+         cc[count-1] = cctmp;
+         }
+   }
+   
+   if (cp) exit_error(PARAMETER_PROBLEM,
+         "geoip match: too many countries specified");
+   free(buffer);
+
+   if (count == 0) exit_error(PARAMETER_PROBLEM,
+         "geoip match: don't know what happened");
+   
+   return count;
+}
+
+static int 
+parse(int c, char **argv, int invert, unsigned int *flags,
+                 const struct ipt_entry *entry,
+                 unsigned int *nfcache,
+                 struct ipt_entry_match **match)
+{
+   struct ipt_geoip_info *info
+      = (struct ipt_geoip_info *)(*match)->data;
+  
+    switch(c) {
+      case '1':
+         // Ensure that IPT_GEOIP_SRC *OR* IPT_GEOIP_DST haven't been used yet.
+         if (*flags & (IPT_GEOIP_SRC | IPT_GEOIP_DST))
+            exit_error(PARAMETER_PROBLEM,
+                  "geoip match: only use --source-country *OR* --destination-country once!");
+ 
+         *flags |= IPT_GEOIP_SRC;
+         *nfcache |= NFC_IP_SRC;
+         break;
+         
+      case '2':
+         // Ensure that IPT_GEOIP_SRC *OR* IPT_GEOIP_DST haven't been used yet.
+         if (*flags & (IPT_GEOIP_SRC | IPT_GEOIP_DST))
+            exit_error(PARAMETER_PROBLEM,
+                  "geoip match: only use --source-country *OR* --destination-country once!");
+ 
+         *flags |= IPT_GEOIP_DST;
+         *nfcache |= NFC_IP_DST;
+         break;
+      
+      default:
+         return 0;
+    }
+    
+    if (invert)
+       *flags |= IPT_GEOIP_INV;
+   
+    info->count = parse_geoip_cc(argv[optind-1], info->cc, info->mem);
+    info->flags = *flags;
+    info->refcount = NULL;
+    //info->fini = &geoip_free;
+
+    return 1;
+}
+
+static void 
+final_check(unsigned int flags)
+{
+   if (!flags)
+      exit_error(PARAMETER_PROBLEM,
+            "geoip match: missing arguments");
+}
+
+static void 
+print(const struct ipt_ip *ip,
+                  const struct ipt_entry_match *match,
+                  int numeric)
+{
+   const struct ipt_geoip_info *info
+      = (const struct ipt_geoip_info *)match->data;
+   
+   u_int8_t i;
+   
+   if (info->flags & IPT_GEOIP_SRC)
+      printf("Source ");
+   else printf("Destination ");
+   
+   if (info->count > 1)
+      printf("countries: ");
+   else printf("country: ");
+   
+   if (info->flags & IPT_GEOIP_INV)
+      printf("! ");
+      
+   for (i = 0; i < info->count; i++)
+       printf("%s%c%c", i ? "," : "", COUNTRY(info->cc[i]));
+   printf(" ");
+}
+
+static void 
+save(const struct ipt_ip *ip,
+                 const struct ipt_entry_match *match)
+{
+   const struct ipt_geoip_info *info
+      = (const struct ipt_geoip_info *)match->data;
+   u_int8_t i;
+
+   if (info->flags & IPT_GEOIP_INV)
+      printf("! ");
+ 
+   if (info->flags & IPT_GEOIP_SRC)
+      printf("--source-country ");
+   else printf("--destination-country ");
+      
+   for (i = 0; i < info->count; i++)
+      printf("%s%c%c", i ? "," : "", COUNTRY(info->cc[i]));
+   printf(" ");
+}
+
+static struct iptables_match geoip = {
+    .name            = "geoip",
+    .version         = IPTABLES_VERSION,
+    .size            = IPT_ALIGN(sizeof(struct ipt_geoip_info)),
+    .userspacesize   = offsetof(struct ipt_geoip_info, mem),
+    .help            = &help,
+    .init            = &init,
+    .parse           = &parse,
+    .final_check     = &final_check,
+    .print           = &print,
+    .save            = &save,
+    .extra_opts      = opts
+};
+
+void _init(void)
+{
+   register_match(&geoip);
+}
diff -urN iptables-1.3.8/extensions/libipt_geoip.man iptables/extensions/libipt_geoip.man
--- iptables-1.3.8/extensions/libipt_geoip.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_geoip.man	2006-12-06 04:08:33.000000000 +0100
@@ -0,0 +1,15 @@
+Match a packet by its source or destination country.
+.TP
+[\fB!\fR] \fB--src-cc\fR, \fB--source-country \fIcountry\fR[\fB,\fIcountry\fB,\fIcountry\fB,\fI...\fR]
+Match packet coming from (one of) the specified country(ies)
+.TP
+[\fB!\fR] \fB--dst-cc\fR, \fB--destination-country \fIcountry\fR[\fB,\fIcountry\fB,\fIcountry\fB,\fI...\fR]
+Match packet going to (one of) the specified country(ies)
+.TP
+NOTE:
+The country is inputed by its ISO3166 code.
+.P
+The only extra files you need is a binary db (geoipdb.bin) & its index file (geoipdb.idx).
+Both files are generated from a countries & subnets database with the csv2bin tool,
+available at http://people.netfilter.org/peejix/geoip/. Both files MUST also be moved in /var/geoip/
+as the shared library is statically looking for that pathname (ex.: /var/geoip/geoipdb.bin).
diff -urN iptables-1.3.8/extensions/libipt_ipp2p.c iptables/extensions/libipt_ipp2p.c
--- iptables-1.3.8/extensions/libipt_ipp2p.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_ipp2p.c	2006-03-29 10:59:21.000000000 +0200
@@ -0,0 +1,401 @@
+
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <ctype.h>
+
+#include <iptables.h>
+
+#include <linux/netfilter_ipv4/ipt_ipp2p.h>
+
+static void
+help(void)
+{
+    printf(
+    "IPP2P v%s options:\n"
+    " --ipp2p	Grab all known p2p packets\n"
+    " --edk		[TCP&UDP]	All known eDonkey/eMule/Overnet packets\n"
+    " --dc		[TCP] 		All known Direct Connect packets\n"
+    " --kazaa	[TCP&UDP] 	All known KaZaA packets\n"
+    " --gnu		[TCP&UDP]	All known Gnutella packets\n"
+    " --bit		[TCP&UDP]	All known BitTorrent packets\n"
+    " --apple	[TCP] 		All known AppleJuice packets\n"
+    " --winmx	[TCP] 		All known WinMX\n"
+    " --soul		[TCP] 		All known SoulSeek\n"
+    " --ares		[TCP] 		All known Ares\n\n"
+    " EXPERIMENTAL protocols (please send feedback to: ipp2p@ipp2p.org) :\n"
+    " --mute		[TCP]		All known Mute packets\n"
+    " --waste	[TCP]		All known Waste packets\n"
+    " --xdcc		[TCP]		All known XDCC packets (only xdcc login)\n\n"
+    " DEBUG SUPPPORT, use only if you know why\n"
+    " --debug		Generate kernel debug output, THIS WILL SLOW DOWN THE FILTER\n"
+    "\nNote that the follwing options will have the same meaning:\n"
+    " '--ipp2p' is equal to '--edk --dc --kazaa --gnu --bit --apple --winmx --soul --ares'\n"
+    "\nIPP2P was intended for TCP only. Due to increasing usage of UDP we needed to change this.\n"
+    "You can now use -p udp to search UDP packets only or without -p switch to search UDP and TCP packets.\n"
+    "\nSee README included with this package for more details or visit http://www.ipp2p.org\n"
+    "\nExamples:\n"
+    " iptables -A FORWARD -m ipp2p --ipp2p -j MARK --set-mark 0x01\n"
+    " iptables -A FORWARD -p udp -m ipp2p --kazaa --bit -j DROP\n"
+    " iptables -A FORWARD -p tcp -m ipp2p --edk --soul -j DROP\n\n"
+    , IPP2P_VERSION);
+}
+
+static struct option opts[] = {
+        { "ipp2p", 0, 0, '1' },
+        { "edk", 0, 0, '2' },	
+	{ "dc", 0, 0, '7' },
+	{ "gnu", 0, 0, '9' },
+	{ "kazaa", 0, 0, 'a' },
+	{ "bit", 0, 0, 'b' },
+	{ "apple", 0, 0, 'c' },	
+	{ "soul", 0, 0, 'd' },	
+	{ "winmx", 0, 0, 'e' },	
+	{ "ares", 0, 0, 'f' },
+	{ "mute", 0, 0, 'g' },
+	{ "waste", 0, 0, 'h' },
+	{ "xdcc", 0, 0, 'i' },
+	{ "debug", 0, 0, 'j' },
+        {0}
+};
+
+	
+
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)m->data;
+
+    *nfcache |= NFC_UNKNOWN;
+
+    /*init the module with default values*/
+    info->cmd = 0;
+    info->debug = 0;
+
+}
+	
+
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+	const struct ipt_entry *entry,
+	unsigned int *nfcache,
+	struct ipt_entry_match **match)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)(*match)->data;
+    
+    switch (c) {
+	case '1':		/*cmd: ipp2p*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags) != 0)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += SHORT_HAND_IPP2P;
+	    info->cmd = *flags;
+	    break;
+	    
+	case '2':		/*cmd: edk*/
+	    if ((*flags & IPP2P_EDK) == IPP2P_EDK)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--edk' may only be "
+				"specified once");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+            if ((*flags & IPP2P_DATA_EDK) == IPP2P_DATA_EDK)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--edk' OR `--edk-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    *flags += IPP2P_EDK;
+	    info->cmd = *flags;	    
+	    break;
+
+
+	case '7':		/*cmd: dc*/
+            if ((*flags & IPP2P_DC) == IPP2P_DC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--dc' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+            if ((*flags & IPP2P_DATA_DC) == IPP2P_DATA_DC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--dc' OR `--dc-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_DC;
+	    info->cmd = *flags;
+	    break;
+
+
+	case '9':		/*cmd: gnu*/
+            if ((*flags & IPP2P_GNU) == IPP2P_GNU)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--gnu' may only be "
+                                "specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+            if ((*flags & IPP2P_DATA_GNU) == IPP2P_DATA_GNU)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--gnu' OR `--gnu-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_GNU;
+	    info->cmd = *flags;
+	    break;
+
+	case 'a':		/*cmd: kazaa*/
+            if ((*flags & IPP2P_KAZAA) == IPP2P_KAZAA)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--kazaa' may only be "
+                                "specified once!");
+/*	    if ((*flags & SHORT_HAND_DATA) == SHORT_HAND_DATA)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p-data' may only be "
+				"specified alone!");*/
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+            if ((*flags & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: use `--kazaa' OR `--kazaa-data' but not both of them!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_KAZAA;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'b':		/*cmd: bit*/
+            if ((*flags & IPP2P_BIT) == IPP2P_BIT)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--bit' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_BIT;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'c':		/*cmd: apple*/
+            if ((*flags & IPP2P_APPLE) == IPP2P_APPLE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--apple' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_APPLE;
+	    info->cmd = *flags;
+	    break;																											
+
+
+	case 'd':		/*cmd: soul*/
+            if ((*flags & IPP2P_SOUL) == IPP2P_SOUL)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--soul' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_SOUL;
+	    info->cmd = *flags;
+	    break;																											
+
+
+	case 'e':		/*cmd: winmx*/
+            if ((*flags & IPP2P_WINMX) == IPP2P_WINMX)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--winmx' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WINMX;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'f':		/*cmd: ares*/
+            if ((*flags & IPP2P_ARES) == IPP2P_ARES)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if ((*flags & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P)
+		    exit_error(PARAMETER_PROBLEM,
+				"ipp2p: `--ipp2p' may only be "
+				"specified alone!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_ARES;
+	    info->cmd = *flags;
+	    break;																											
+	
+	case 'g':		/*cmd: mute*/
+            if ((*flags & IPP2P_MUTE) == IPP2P_MUTE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--mute' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_MUTE;
+	    info->cmd = *flags;
+	    break;																											
+	case 'h':		/*cmd: waste*/
+            if ((*flags & IPP2P_WASTE) == IPP2P_WASTE)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--waste' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_WASTE;
+	    info->cmd = *flags;
+	    break;																											
+	case 'i':		/*cmd: xdcc*/
+            if ((*flags & IPP2P_XDCC) == IPP2P_XDCC)
+            exit_error(PARAMETER_PROBLEM,
+                                "ipp2p: `--ares' may only be "
+                                "specified once!");
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+            *flags += IPP2P_XDCC;
+	    info->cmd = *flags;
+	    break;																											
+
+	case 'j':		/*cmd: debug*/
+	    if (invert) exit_error(PARAMETER_PROBLEM, "ipp2p: invert [!] is not allowed!");
+	    info->debug = 1;
+	    break;																											
+
+	default:
+//            exit_error(PARAMETER_PROBLEM,
+//	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+	    return 0;
+    }
+    return 1;
+}
+
+
+static void
+final_check(unsigned int flags)
+{
+    if (!flags)
+            exit_error(PARAMETER_PROBLEM,
+	    "\nipp2p-parameter problem: for ipp2p usage type: iptables -m ipp2p --help\n");
+}
+
+
+
+static void
+print(const struct ipt_ip *ip,
+        const struct ipt_entry_match *match,
+	int numeric)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+    
+    printf("ipp2p v%s", IPP2P_VERSION);
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf(" --ipp2p");
+//    if ((info->cmd & SHORT_HAND_DATA) == SHORT_HAND_DATA) printf(" --ipp2p-data");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf(" --kazaa");
+//    if ((info->cmd & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA) printf(" --kazaa-data");
+//    if ((info->cmd & IPP2P_DATA_GNU) == IPP2P_DATA_GNU) printf(" --gnu-data");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf(" --gnu");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf(" --edk");
+//    if ((info->cmd & IPP2P_DATA_EDK) == IPP2P_DATA_EDK) printf(" --edk-data");
+//    if ((info->cmd & IPP2P_DATA_DC) == IPP2P_DATA_DC) printf(" --dc-data");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf(" --dc");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf(" --bit");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf(" --apple");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf(" --soul");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf(" --winmx");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf(" --ares");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf(" --debug");
+    printf(" ");
+}
+			    						   
+
+
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+    struct ipt_p2p_info *info = (struct ipt_p2p_info *)match->data;
+    
+    if ((info->cmd & SHORT_HAND_IPP2P) == SHORT_HAND_IPP2P) printf("--ipp2p ");
+//    if ((info->cmd & SHORT_HAND_DATA) == SHORT_HAND_DATA) printf("--ipp2p-data ");
+    if ((info->cmd & IPP2P_KAZAA) == IPP2P_KAZAA) printf("--kazaa ");
+//    if ((info->cmd & IPP2P_DATA_KAZAA) == IPP2P_DATA_KAZAA) printf("--kazaa-data ");
+//    if ((info->cmd & IPP2P_DATA_GNU) == IPP2P_DATA_GNU) printf("--gnu-data ");
+    if ((info->cmd & IPP2P_GNU) == IPP2P_GNU) printf("--gnu ");
+    if ((info->cmd & IPP2P_EDK) == IPP2P_EDK) printf("--edk ");
+//    if ((info->cmd & IPP2P_DATA_EDK) == IPP2P_DATA_EDK) printf("--edk-data ");
+//    if ((info->cmd & IPP2P_DATA_DC) == IPP2P_DATA_DC) printf("--dc-data ");
+    if ((info->cmd & IPP2P_DC) == IPP2P_DC) printf("--dc ");
+    if ((info->cmd & IPP2P_BIT) == IPP2P_BIT) printf("--bit ");
+    if ((info->cmd & IPP2P_APPLE) == IPP2P_APPLE) printf("--apple ");
+    if ((info->cmd & IPP2P_SOUL) == IPP2P_SOUL) printf("--soul ");
+    if ((info->cmd & IPP2P_WINMX) == IPP2P_WINMX) printf("--winmx ");
+    if ((info->cmd & IPP2P_ARES) == IPP2P_ARES) printf("--ares ");
+    if ((info->cmd & IPP2P_MUTE) == IPP2P_MUTE) printf(" --mute");
+    if ((info->cmd & IPP2P_WASTE) == IPP2P_WASTE) printf(" --waste");
+    if ((info->cmd & IPP2P_XDCC) == IPP2P_XDCC) printf(" --xdcc");
+    if (info->debug != 0) printf("--debug ");
+}
+
+		
+
+
+static 
+struct iptables_match ipp2p= 
+{ 
+    .next           = NULL,
+    .name           = "ipp2p",
+    .version        = IPTABLES_VERSION,
+    .size           = IPT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .userspacesize  = IPT_ALIGN(sizeof(struct ipt_p2p_info)),
+    .help           = &help,
+    .init           = &init,
+    .parse          = &parse,
+    .final_check    = &final_check,
+    .print          = &print,
+    .save           = &save,
+    .extra_opts     = opts
+};
+					    
+
+
+void _init(void)
+{
+    register_match(&ipp2p);
+}
+
diff -urN iptables-1.3.8/extensions/libipt_ipp2p.man iptables/extensions/libipt_ipp2p.man
--- iptables-1.3.8/extensions/libipt_ipp2p.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_ipp2p.man	2005-02-01 11:09:48.000000000 +0100
@@ -0,0 +1,43 @@
+This module matches certain packets in P2P flows. It is not
+designed to match all packets belonging to a P2P connection - 
+use IPP2P together with CONNMARK for this purpose. Also visit
+http://www.ipp2p.org for detailed information.
+
+Use it together with -p tcp or -p udp to search these protocols
+only or without -p switch to search packets of both protocols.
+
+IPP2P provides the following options:
+.TP
+.B "--edk "
+Matches as many eDonkey/eMule packets as possible.
+.TP
+.B "--kazaa "
+Matches as many KaZaA packets as possible.
+.TP
+.B "--gnu "
+Matches as many Gnutella packets as possible.
+.TP
+.B "--dc "
+Matches as many Direct Connect packets as possible.
+.TP
+.B "--bit "
+Matches BitTorrent packets.
+.TP
+.B "--apple "
+Matches AppleJuice packets.
+.TP
+.B "--soul "
+Matches some SoulSeek packets. Considered as beta, use careful!
+.TP
+.B "--winmx "
+Matches some WinMX packets. Considered as beta, use careful!
+.TP
+.B "--ares "
+Matches Ares and AresLite packets. Use together with -j DROP only.
+.TP
+.B "--ipp2p "
+Short hand for: --edk --kazaa --gnu --dc
+.TP
+.B "--debug "
+Prints some information about each hit into kernel logfile. May 
+produce huge logfiles so beware!
diff -urN iptables-1.3.8/extensions/libipt_ipv4options.c iptables/extensions/libipt_ipv4options.c
--- iptables-1.3.8/extensions/libipt_ipv4options.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_ipv4options.c	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,311 @@
+/* Shared library add-on to iptables to add ipv4 options matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_ipv4options.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"ipv4options v%s options:\n"
+"      --ssrr    (match strict source routing flag)\n"
+"      --lsrr    (match loose  source routing flag)\n"
+"      --no-srr  (match packets with no source routing)\n\n"
+"  [!] --rr      (match record route flag)\n\n"
+"  [!] --ts      (match timestamp flag)\n\n"
+"  [!] --ra      (match router-alert option)\n\n"
+"  [!] --any-opt (match any option or no option at all if used with '!')\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "ssrr", 0, 0, '1' },
+	{ "lsrr", 0, 0, '2' },
+	{ "no-srr", 0, 0, '3'},
+	{ "rr", 0, 0, '4'},
+	{ "ts", 0, 0, '5'},
+	{ "ra", 0, 0, '6'},
+	{ "any-opt", 0, 0, '7'},
+	{0}
+};
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_ipv4options_info *info = (struct ipt_ipv4options_info *)(*match)->data;
+
+	switch (c)
+	{
+		/* strict-source-routing */
+	case '1':
+		if (invert) 
+			exit_error(PARAMETER_PROBLEM,
+				   "ipv4options: unexpected `!' with --ssrr");
+		if (*flags & IPT_IPV4OPTION_MATCH_SSRR)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --ssrr twice");
+		if (*flags & IPT_IPV4OPTION_MATCH_LSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ssrr with --lsrr");
+		if (*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ssrr with --no-srr");
+
+		info->options |= IPT_IPV4OPTION_MATCH_SSRR;
+		*flags |= IPT_IPV4OPTION_MATCH_SSRR;
+		break;
+
+		/* loose-source-routing */
+	case '2':
+		if (invert) 
+			exit_error(PARAMETER_PROBLEM,
+				   "ipv4options: unexpected `!' with --lsrr");
+		if (*flags & IPT_IPV4OPTION_MATCH_SSRR)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --lsrr twice");
+		if (*flags & IPT_IPV4OPTION_MATCH_LSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --lsrr with --ssrr");
+		if (*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --lsrr with --no-srr");
+		info->options |= IPT_IPV4OPTION_MATCH_LSRR;
+		*flags |= IPT_IPV4OPTION_MATCH_LSRR;
+		break;
+
+		/* no-source-routing */
+	case '3':
+		if (invert) 
+			exit_error(PARAMETER_PROBLEM,
+					   "ipv4options: unexpected `!' with --no-srr");
+		if (*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --no-srr twice");
+		if (*flags & IPT_IPV4OPTION_MATCH_SSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --no-srr with --ssrr");
+		if (*flags & IPT_IPV4OPTION_MATCH_LSRR)
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --no-srr with --lsrr");
+		info->options |= IPT_IPV4OPTION_DONT_MATCH_SRR;
+		*flags |= IPT_IPV4OPTION_DONT_MATCH_SRR;
+		break;
+
+		/* record-route */
+	case '4':
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --rr twice");	
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --rr twice");
+		if ((!invert) && (*flags & IPT_IPV4OPTION_DONT_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --rr with ! --rr");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_RR))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --rr with --rr");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_RR;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_RR;
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_RR;
+			*flags |= IPT_IPV4OPTION_MATCH_RR;
+		}
+		break;
+
+		/* timestamp */
+	case '5':
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ts twice");	
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --ts twice");
+		if ((!invert) && (*flags & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ts with ! --ts");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_TIMESTAMP))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --ts with --ts");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP;
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_TIMESTAMP;
+			*flags |= IPT_IPV4OPTION_MATCH_TIMESTAMP;
+		}
+		break;
+
+		/* router-alert  */
+	case '6':
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ra twice");	
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --rr twice");
+		if ((!invert) && (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --ra with ! --ra");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --ra with --ra");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT;
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_ROUTER_ALERT;
+			*flags |= IPT_IPV4OPTION_MATCH_ROUTER_ALERT;
+		}
+		break;
+
+		/* any option */
+	case '7' :
+		if ((!invert) && (*flags & IPT_IPV4OPTION_MATCH_ANY_OPT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --any-opt twice");
+		if (invert && (*flags & IPT_IPV4OPTION_MATCH_ANY_OPT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --any-opt with --any-opt");
+		if (invert && (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --any-opt twice");
+		if ((!invert) &&
+		    ((*flags & IPT_IPV4OPTION_DONT_MATCH_SRR)       ||
+		     (*flags & IPT_IPV4OPTION_DONT_MATCH_RR)        ||
+		     (*flags & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP) ||
+		     (*flags & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify --any-opt with any other negative ipv4options match");
+		if (invert &&
+		    ((*flags & IPT_IPV4OPTION_MATCH_LSRR)      ||
+		     (*flags & IPT_IPV4OPTION_MATCH_SSRR)      ||
+		     (*flags & IPT_IPV4OPTION_MATCH_RR)        ||
+		     (*flags & IPT_IPV4OPTION_MATCH_TIMESTAMP) ||
+		     (*flags & IPT_IPV4OPTION_MATCH_ROUTER_ALERT)))
+			exit_error(PARAMETER_PROBLEM,
+				   "Can't specify ! --any-opt with any other positive ipv4options match");
+		if (invert) {
+			info->options |= IPT_IPV4OPTION_DONT_MATCH_ANY_OPT;
+			*flags |= IPT_IPV4OPTION_DONT_MATCH_ANY_OPT;	
+		}
+		else {
+			info->options |= IPT_IPV4OPTION_MATCH_ANY_OPT;
+			*flags |= IPT_IPV4OPTION_MATCH_ANY_OPT;
+		}
+		break;
+
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+static void
+final_check(unsigned int flags)
+{
+	if (flags == 0)
+		exit_error(PARAMETER_PROBLEM,
+			   "ipv4options match: you must specify some parameters. See iptables -m ipv4options --help for help.'");
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_ipv4options_info *info = ((struct ipt_ipv4options_info *)match->data);
+
+	printf(" IPV4OPTS");
+	if (info->options & IPT_IPV4OPTION_MATCH_SSRR)
+		printf(" SSRR");
+	else if (info->options & IPT_IPV4OPTION_MATCH_LSRR)
+		printf(" LSRR");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_SRR)
+		printf(" !SRR");
+	if (info->options & IPT_IPV4OPTION_MATCH_RR)
+		printf(" RR");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_RR)
+		printf(" !RR");
+	if (info->options & IPT_IPV4OPTION_MATCH_TIMESTAMP)
+		printf(" TS");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP)
+		printf(" !TS");
+	if (info->options & IPT_IPV4OPTION_MATCH_ROUTER_ALERT)
+		printf(" RA");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT)
+		printf(" !RA");
+	if (info->options & IPT_IPV4OPTION_MATCH_ANY_OPT)
+		printf(" ANYOPT ");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_ANY_OPT)
+		printf(" NOOPT");
+
+	printf(" ");
+}
+
+/* Saves the data in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_ipv4options_info *info = ((struct ipt_ipv4options_info *)match->data);
+
+	if (info->options & IPT_IPV4OPTION_MATCH_SSRR)
+		printf(" --ssrr");
+	else if (info->options & IPT_IPV4OPTION_MATCH_LSRR)
+		printf(" --lsrr");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_SRR)
+		printf(" --no-srr");
+	if (info->options & IPT_IPV4OPTION_MATCH_RR)
+		printf(" --rr");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_RR)
+		printf(" ! --rr");
+	if (info->options & IPT_IPV4OPTION_MATCH_TIMESTAMP)
+		printf(" --ts");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_TIMESTAMP)
+		printf(" ! --ts");
+	if (info->options & IPT_IPV4OPTION_MATCH_ROUTER_ALERT)
+		printf(" --ra");
+	else if (info->options & IPT_IPV4OPTION_DONT_MATCH_ROUTER_ALERT)
+		printf(" ! --ra");
+	if (info->options & IPT_IPV4OPTION_MATCH_ANY_OPT)
+		printf(" --any-opt");
+	if (info->options & IPT_IPV4OPTION_DONT_MATCH_ANY_OPT)
+		printf(" ! --any-opt");
+
+	printf(" ");
+}
+
+static struct iptables_match ipv4options_struct = { 
+	.next		= NULL,
+	.name		= "ipv4options",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_ipv4options_info)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&ipv4options_struct);
+}
diff -urN iptables-1.3.8/extensions/libipt_ipv4options.man iptables/extensions/libipt_ipv4options.man
--- iptables-1.3.8/extensions/libipt_ipv4options.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_ipv4options.man	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,32 @@
+Match on IPv4 header options like source routing, record route,
+timestamp and router-alert.
+.TP
+.B "--ssrr"
+To match packets with the flag strict source routing.
+.TP
+.B "--lsrr"
+To match packets with the flag loose source routing.
+.TP
+.B "--no-srr"
+To match packets with no flag for source routing.
+.TP
+.B "\fR[\fB!\fR]\fB --rr"
+To match packets with the RR flag.
+.TP
+.B "\fR[\fB!\fR]\fB --ts"
+To match packets with the TS flag.
+.TP
+.B "\fR[\fB!\fR]\fB --ra"
+To match packets with the router-alert option.
+.TP
+.B "\fR[\fB!\fR]\fB --any-opt"
+To match a packet with at least one IP option, or no IP option
+at all if ! is chosen.
+.TP
+Examples:
+.TP
+$ iptables -A input -m ipv4options --rr -j DROP
+will drop packets with the record-route flag.
+.TP
+$ iptables -A input -m ipv4options --ts -j DROP
+will drop packets with the timestamp flag.
diff -urN iptables-1.3.8/extensions/libipt_time.c iptables/extensions/libipt_time.c
--- iptables-1.3.8/extensions/libipt_time.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_time.c	2006-12-04 12:15:20.000000000 +0100
@@ -0,0 +1,549 @@
+/* Shared library add-on to iptables to add TIME matching support. */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <stddef.h> /* for 'offsetof' */
+#include <getopt.h>
+
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_time.h>
+#include <time.h>
+
+static int globaldays;
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TIME v%s options:\n"
+" [ --timestart value ] [ --timestop value] [ --days listofdays ] [ --datestart value ] [ --datestop value ]\n"
+"          timestart value : HH:MM (default 00:00)\n"
+"          timestop  value : HH:MM (default 23:59)\n"
+"                            Note: daylight savings time changes are not tracked\n"
+"          listofdays value: a list of days to apply\n"
+"                            from Mon,Tue,Wed,Thu,Fri,Sat,Sun\n"
+"                            Coma speparated, no space, case sensitive.\n"
+"                            Defaults to all days.\n"
+"          datestart value : YYYY[:MM[:DD[:hh[:mm[:ss]]]]]\n"
+"                            If any of month, day, hour, minute or second is\n"
+"                            not specified, then defaults to their smallest\n"
+"                            1900 <= YYYY < 2037\n"
+"                               1 <= MM <= 12\n"
+"                               1 <= DD <= 31\n"
+"                               0 <= hh <= 23\n"
+"                               0 <= mm <= 59\n"
+"                               0 <= ss <= 59\n"
+"          datestop  value : YYYY[:MM[:DD[:hh[:mm[:ss]]]]]\n"
+"                            If the whole option is ommited, default to never stop\n"
+"                            If any of month, day, hour, minute or second is\n"
+"                            not specified, then default to their smallest\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ "timestart", 1, 0, '1' },
+	{ "timestop", 1, 0, '2' },
+	{ "days", 1, 0, '3'},
+	{ "datestart", 1, 0, '4' },
+	{ "datestop", 1, 0, '5' },
+	{0}
+};
+
+/* Initialize the match. */
+static void
+init(struct ipt_entry_match *m, unsigned int *nfcache)
+{
+	struct ipt_time_info *info = (struct ipt_time_info *)m->data;
+	globaldays = 0;
+        /* By default, we match on everyday */
+	info->days_match = 127;
+	/* By default, we match on every hour:min of the day */
+	info->time_start = 0;
+	info->time_stop  = 1439;  /* (23*60+59 = 1439 */
+	/* By default, we don't have any date-begin or date-end boundaries */
+	info->date_start = 0;
+	info->date_stop  = LONG_MAX;
+}
+
+/**
+ * param: part1, a pointer on a string 2 chars maximum long string, that will contain the hours.
+ * param: part2, a pointer on a string 2 chars maximum long string, that will contain the minutes.
+ * param: str_2_parse, the string to parse.
+ * return: 1 if ok, 0 if error.
+ */
+static int
+split_time(char **part1, char **part2, const char *str_2_parse)
+{
+	unsigned short int i,j=0;
+	char *rpart1 = *part1;
+	char *rpart2 = *part2;
+	unsigned char found_column = 0;
+
+	/* Check the length of the string */
+	if (strlen(str_2_parse) > 5)
+		return 0;
+	/* parse the first part until the ':' */
+	for (i=0; i<2; i++)
+	{
+		if (str_2_parse[i] == ':')
+			found_column = 1;
+		else
+			rpart1[i] = str_2_parse[i];
+	}
+	if (!found_column)
+		i++;
+	j=i;
+	/* parse the second part */
+	for (; i<strlen(str_2_parse); i++)
+	{
+		rpart2[i-j] = str_2_parse[i];
+	}
+	/* if we are here, format should be ok. */
+	return 1;
+}
+
+static int
+parse_number(char *str, int num_min, int num_max, int *number)
+{
+	/* if the number starts with 0, replace it with a space else
+	string_to_number() will interpret it as octal !! */
+	if (strlen(str) == 0)
+		return 0;
+
+	if ((str[0] == '0') && (str[1] != '\0'))
+		str[0] = ' ';
+
+	return string_to_number(str, num_min, num_max, number);
+}
+
+static void
+parse_time_string(int *hour, int *minute, const char *time)
+{
+	char *hours;
+	char *minutes;
+	hours = (char *)malloc(3);
+	minutes = (char *)malloc(3);
+	memset(hours, 0, 3);
+	memset(minutes, 0, 3);
+
+	if (split_time((char **)&hours, (char **)&minutes, time) == 1)
+	{
+		*hour = 0;
+		*minute = 0;
+		if ((parse_number((char *)hours, 0, 23, hour) != -1) &&
+		    (parse_number((char *)minutes, 0, 59, minute) != -1))
+		{
+			free(hours);
+			free(minutes);
+			return;
+		}
+	}
+
+	free(hours);
+	free(minutes);
+
+	/* If we are here, there was a problem ..*/
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid time `%s' specified, should be HH:MM format", time);
+}
+
+/* return 1->ok, return 0->error */
+static int
+parse_day(int *days, int from, int to, const char *string)
+{
+	char *dayread;
+	char *days_str[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+	unsigned short int days_of_week[7] = {64, 32, 16, 8, 4, 2, 1};
+	unsigned int i;
+
+	dayread = (char *)malloc(4);
+	bzero(dayread, 4);
+	if ((to-from) != 3) {
+		free(dayread);
+		return 0;
+	}
+	for (i=from; i<to; i++)
+		dayread[i-from] = string[i];
+	for (i=0; i<7; i++)
+		if (strcmp(dayread, days_str[i]) == 0)
+		{
+			*days |= days_of_week[i];
+			free(dayread);
+			return 1;
+		}
+	/* if we are here, we didn't read a valid day */
+	free(dayread);
+	return 0;
+}
+
+static void
+parse_days_string(int *days, const char *daystring)
+{
+	int len;
+	int i=0;
+	char *err = "invalid days `%s' specified, should be Sun,Mon,Tue... format";
+
+	len = strlen(daystring);
+	if (len < 3)
+		exit_error(PARAMETER_PROBLEM, err, daystring);	
+	while(i<len)
+	{
+		if (parse_day(days, i, i+3, daystring) == 0)
+			exit_error(PARAMETER_PROBLEM, err, daystring);
+		i += 4;
+	}
+}
+
+static int
+parse_date_field(const char *str_to_parse, int str_to_parse_s, int start_pos,
+                 char *dest, int *next_pos)
+{
+	unsigned char found_value = 0;
+	unsigned char found_column = 0;
+	int i;
+
+	for (i=0; i<2; i++)
+	{
+		if ((i+start_pos) >= str_to_parse_s) /* don't exit boundaries of the string..  */
+			break;
+		if (str_to_parse[i+start_pos] == ':')
+			found_column = 1;
+		else
+		{
+			found_value = 1;
+			dest[i] = str_to_parse[i+start_pos];
+		}
+	}
+	if (found_value == 0)
+		return 0;
+	*next_pos = i + start_pos;
+	if (found_column == 0)
+		++(*next_pos);
+	return 1;
+}
+
+static int
+split_date(char *year, char *month,  char *day,
+           char *hour, char *minute, char *second,
+           const char *str_to_parse)
+{
+        int i;
+        unsigned char found_column = 0;
+	int str_to_parse_s = strlen(str_to_parse);
+
+        /* Check the length of the string */
+        if ((str_to_parse_s > 19) ||  /* YYYY:MM:DD:HH:MM:SS */
+            (str_to_parse_s < 4))     /* YYYY*/
+                return 0;
+
+	/* Clear the buffers */
+        memset(year, 0, 4);
+	memset(month, 0, 2);
+	memset(day, 0, 2);
+	memset(hour, 0, 2);
+	memset(minute, 0, 2);
+	memset(second, 0, 2);
+
+	/* parse the year YYYY */
+	found_column = 0;
+	for (i=0; i<5; i++)
+	{
+		if (i >= str_to_parse_s)
+			break;
+		if (str_to_parse[i] == ':')
+		{
+			found_column = 1;
+			break;
+		}
+		else
+			year[i] = str_to_parse[i];
+	}
+	if (found_column == 1)
+		++i;
+
+	/* parse the month if it exists */
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, month, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, day, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, hour, &i))
+		return 1;
+
+	if (! parse_date_field(str_to_parse, str_to_parse_s, i, minute, &i))
+		return 1;
+
+	parse_date_field(str_to_parse, str_to_parse_s, i, second, &i);
+
+        /* if we are here, format should be ok. */
+        return 1;
+}
+
+static time_t
+parse_date_string(const char *str_to_parse)
+{
+	char year[5];
+	char month[3];
+	char day[3];
+	char hour[3];
+	char minute[3];
+	char second[3];
+	struct tm t;
+	time_t temp_time;
+
+	memset(year, 0, 5);
+	memset(month, 0, 3);
+	memset(day, 0, 3);
+	memset(hour, 0, 3);
+	memset(minute, 0, 3);
+	memset(second, 0, 3);
+
+        if (split_date(year, month, day, hour, minute, second, str_to_parse) == 1)
+        {
+		memset((void *)&t, 0, sizeof(struct tm));
+		t.tm_isdst = -1;
+		t.tm_mday = 1;
+		if (!((parse_number(year, 1900, 2037, &(t.tm_year)) == -1) ||
+		      (parse_number(month, 1, 12, &(t.tm_mon)) == -1) ||
+		      (parse_number(day, 1, 31, &(t.tm_mday)) == -1) ||
+		      (parse_number(hour, 0, 9999, &(t.tm_hour)) == -1) ||
+		      (parse_number(minute, 0, 59, &(t.tm_min)) == -1) ||
+		      (parse_number(second, 0, 59, &(t.tm_sec)) == -1)))
+		{
+			t.tm_year -= 1900;
+			--(t.tm_mon);
+			temp_time = mktime(&t);
+			if (temp_time != -1)
+				return temp_time;
+		}
+	}
+	exit_error(PARAMETER_PROBLEM,
+		   "invalid date `%s' specified, should be YYYY[:MM[:DD[:hh[:mm[:ss]]]]] format", str_to_parse);
+}
+
+#define IPT_TIME_START 0x01
+#define IPT_TIME_STOP  0x02
+#define IPT_TIME_DAYS  0x04
+#define IPT_DATE_START 0x08
+#define IPT_DATE_STOP  0x10
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_time_info *timeinfo = (struct ipt_time_info *)(*match)->data;
+	int hours, minutes;
+	time_t temp_date;
+
+	switch (c)
+	{
+		/* timestart */
+	case '1':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --timestart");
+		if (*flags & IPT_TIME_START)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --timestart twice");
+		parse_time_string(&hours, &minutes, optarg);
+		timeinfo->time_start = (hours * 60) + minutes;
+		*flags |= IPT_TIME_START;
+		break;
+		/* timestop */
+	case '2':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --timestop");
+		if (*flags & IPT_TIME_STOP)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --timestop twice");
+		parse_time_string(&hours, &minutes, optarg);
+		timeinfo->time_stop = (hours * 60) + minutes;
+		*flags |= IPT_TIME_STOP;
+		break;
+
+		/* days */
+	case '3':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --days");
+		if (*flags & IPT_TIME_DAYS)
+                        exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --days twice");
+		parse_days_string(&globaldays, optarg);
+		timeinfo->days_match = globaldays;
+		*flags |= IPT_TIME_DAYS;
+		break;
+
+		/* datestart */
+	case '4':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --datestart");
+		if (*flags & IPT_DATE_START)
+			exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --datestart twice");
+		temp_date = parse_date_string(optarg);
+		timeinfo->date_start = temp_date;
+		*flags |= IPT_DATE_START;
+		break;
+
+		/* datestop*/
+	case '5':
+		if (invert)
+			exit_error(PARAMETER_PROBLEM,
+                                   "unexpected '!' with --datestop");
+		if (*flags & IPT_DATE_STOP)
+			exit_error(PARAMETER_PROBLEM,
+                                   "Can't specify --datestop twice");
+		temp_date = parse_date_string(optarg);
+		timeinfo->date_stop = temp_date;
+		*flags |= IPT_DATE_STOP;
+		break;
+	default:
+		return 0;
+	}
+	return 1;
+}
+
+/* Final check */
+static void
+final_check(unsigned int flags)
+{
+	/* Nothing to do */
+}
+
+
+static void
+print_days(int daynum)
+{
+	char *days[7] = {"Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
+	unsigned short int days_of_week[7] = {64, 32, 16, 8, 4, 2, 1};
+	unsigned short int i, nbdays=0;
+
+	for (i=0; i<7; i++) {
+		if ((days_of_week[i] & daynum) == days_of_week[i])
+		{
+			if (nbdays>0)
+				printf(",%s", days[i]);
+			else
+				printf("%s", days[i]);
+			++nbdays;
+		}
+	}
+	printf(" ");
+}
+
+static void
+divide_time(int fulltime, int *hours, int *minutes)
+{
+	*hours = fulltime / 60;
+	*minutes = fulltime % 60;
+}
+
+static void
+print_date(time_t date, char *command)
+{
+	struct tm *t;
+
+	/* If it's default value, don't print..*/
+	if (((date == 0) || (date == LONG_MAX)) && (command != NULL))
+		return;
+	t = localtime(&date);
+	if (command != NULL)
+		printf("%s %d:%d:%d:%d:%d:%d ", command, (t->tm_year + 1900), (t->tm_mon + 1),
+			t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+        else
+        	printf("%d-%d-%d %d:%d:%d ", (t->tm_year + 1900), (t->tm_mon + 1),
+			t->tm_mday, t->tm_hour, t->tm_min, t->tm_sec);
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+	int hour_start, hour_stop, minute_start, minute_stop;
+
+	divide_time(time->time_start, &hour_start, &minute_start);
+	divide_time(time->time_stop, &hour_stop, &minute_stop);
+	printf("TIME ");
+	if (time->time_start != 0)
+		printf("from %d:%d ", hour_start, minute_start);
+	if (time->time_stop != 1439) /* 23*60+59 = 1439 */
+		printf("to %d:%d ", hour_stop, minute_stop);
+	printf("on ");
+	if (time->days_match == 127)
+		printf("all days ");
+	else
+		print_days(time->days_match);
+	if (time->date_start != 0)
+	{
+		printf("starting from ");
+		print_date(time->date_start, NULL);
+	}
+	if (time->date_stop != LONG_MAX)
+	{
+		printf("until date ");
+		print_date(time->date_stop, NULL);
+	}
+}
+
+/* Saves the data in parsable form to stdout. */
+static void
+save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	struct ipt_time_info *time = ((struct ipt_time_info *)match->data);
+	int hour_start, hour_stop, minute_start, minute_stop;
+
+	divide_time(time->time_start, &hour_start, &minute_start);
+	divide_time(time->time_stop, &hour_stop, &minute_stop);
+	if (time->time_start != 0)
+		printf("--timestart %.2d:%.2d ",
+		        hour_start, minute_start);
+	
+	if (time->time_stop != 1439) /* 23*60+59 = 1439 */
+		printf("--timestop %.2d:%.2d ",
+		        hour_stop, minute_stop);
+	
+	if (time->days_match != 127)
+	{
+		printf("--days ");
+		print_days(time->days_match);
+		printf(" ");
+	}
+	print_date(time->date_start, "--datestart");
+	print_date(time->date_stop, "--datestop");
+}
+
+/* have to use offsetof() instead of IPT_ALIGN(), since kerneltime must not
+ * be compared when user deletes rule with '-D' */
+static
+struct iptables_match timestruct = {
+	.next		= NULL,
+	.name		= "time",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_time_info)),
+	.userspacesize	= offsetof(struct ipt_time_info, kerneltime),
+	.help		= &help,
+	.init		= &init,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void _init(void)
+{
+	register_match(&timestruct);
+}
diff -urN iptables-1.3.8/extensions/libipt_time.man iptables/extensions/libipt_time.man
--- iptables-1.3.8/extensions/libipt_time.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_time.man	2006-12-04 12:15:20.000000000 +0100
@@ -0,0 +1,16 @@
+This matches if the packet arrival time/date is within a given range. All options are facultative.
+.TP
+.BI " --timestart " "value"
+Match only if it is after `value' (Inclusive, format: HH:MM ; default 00:00).
+.TP
+.BI "--timestop  " "value"
+Match only if it is before `value' (Inclusive, format: HH:MM ; default 23:59).
+.TP
+.BI "--days " "listofdays"
+Match only if today is one of the given days. (format: Mon,Tue,Wed,Thu,Fri,Sat,Sun ; default everyday)
+.TP
+.BI "--datestart " "date"
+Match only if it is after `date' (Inclusive, format: YYYY[:MM[:DD[:hh[:mm[:ss]]]]] ; h,m,s start from 0 ; default to 1970)
+.TP
+.BI "--datestop " "date"
+Match only if it is before `date' (Inclusive, format: YYYY[:MM[:DD[:hh[:mm[:ss]]]]] ; h,m,s start from 0 ; default to 2037)
diff -urN iptables-1.3.8/extensions/libipt_u32.c iptables/extensions/libipt_u32.c
--- iptables-1.3.8/extensions/libipt_u32.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_u32.c	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,264 @@
+/* Shared library add-on to iptables to add u32 matching,
+ * generalized matching on values found at packet offsets
+ *
+ * Detailed doc is in the kernel module source
+ * net/ipv4/netfilter/ipt_u32.c
+ *
+ * (C) 2002 by Don Cohen <don-netf@isis.cs3-inc.com>
+ * Released under the terms of GNU GPL v2
+ */
+#include <stdio.h>
+#include <netdb.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+#include <iptables.h>
+#include <linux/netfilter_ipv4/ipt_u32.h>
+#include <errno.h>
+#include <ctype.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf( "u32 v%s options:\n"
+		" --u32 tests\n"
+		" tests := location = value | tests && location = value\n"
+		" value := range | value , range\n"
+		" range := number | number : number\n"
+		" location := number | location operator number\n"
+		" operator := & | << | >> | @\n"
+		,IPTABLES_VERSION);
+}
+
+/* defined in /usr/include/getopt.h maybe in man getopt */
+static struct option opts[] = {
+	{ "u32", 1, 0, '1' },
+	{ 0 }
+};
+
+/* shared printing code */
+static void print_u32(struct ipt_u32 *data)
+{
+	unsigned int testind;
+
+	for (testind=0; testind < data->ntests; testind++) {
+		if (testind) printf("&&");
+		{
+			unsigned int i;
+
+			printf("0x%x", data->tests[testind].location[0].number);
+			for (i = 1; i < data->tests[testind].nnums; i++) {
+				switch (data->tests[testind].location[i].nextop) {
+				case IPT_U32_AND: printf("&"); break;
+				case IPT_U32_LEFTSH: printf("<<"); break;
+				case IPT_U32_RIGHTSH: printf(">>"); break;
+				case IPT_U32_AT: printf("@"); break;
+				}
+				printf("0x%x", data->tests[testind].location[i].number);
+			}
+			printf("=");
+			for (i = 0; i < data->tests[testind].nvalues; i++) {
+				if (i) printf(",");
+				if (data->tests[testind].value[i].min
+				    == data->tests[testind].value[i].max)
+					printf("0x%x", data->tests[testind].value[i].min);
+				else printf("0x%x:0x%x", data->tests[testind].value[i].min,
+					    data->tests[testind].value[i].max);
+			}
+		}
+	}
+	printf(" ");
+}
+
+/* string_to_number is not quite what we need here ... */
+u_int32_t parse_number(char **s, int pos)
+{
+	u_int32_t number;
+	char *end;
+	errno = 0;
+
+	number = strtoul(*s, &end, 0);
+	if (end == *s)
+		exit_error(PARAMETER_PROBLEM, 
+			   "u32: at char %d expected number", pos);
+	if (errno)
+		exit_error(PARAMETER_PROBLEM, 
+			   "u32: at char %d error reading number", pos);
+	*s = end;
+	return number;
+}
+
+/* Function which parses command options; returns true if it ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ipt_entry *entry,
+      unsigned int *nfcache,
+      struct ipt_entry_match **match)
+{
+	struct ipt_u32 *data = (struct ipt_u32 *)(*match)->data;
+	char *arg = argv[optind-1]; /* the argument string */
+	char *start = arg;
+	int state=0, testind=0, locind=0, valind=0;
+
+	if (c != '1') return 0;
+	/* states: 0 = looking for numbers and operations, 1 = looking for ranges */
+	while (1) { /* read next operand/number or range */
+		while (isspace(*arg)) 
+			arg++;  /* skip white space */
+		if (! *arg) { /* end of argument found */
+			if (state == 0)
+				exit_error(PARAMETER_PROBLEM, 
+					   "u32: input ended in location spec");
+			if (valind == 0)
+				exit_error(PARAMETER_PROBLEM, 
+					   "u32: test ended with no value spec");
+			data->tests[testind].nnums = locind;
+			data->tests[testind].nvalues = valind;
+			testind++;
+			data->ntests=testind;
+			if (testind > U32MAXSIZE)
+				exit_error(PARAMETER_PROBLEM, 
+					   "u32: at char %d too many &&'s",
+					   arg-start);
+			/* debugging 
+			   print_u32(data);printf("\n");
+			   exit_error(PARAMETER_PROBLEM, "debugging output done"); */
+			return 1;
+		}
+		if (state == 0) {
+			/* reading location: read a number if nothing read yet,
+			   otherwise either op number or = to end location spec */	 
+			if (*arg == '=') {
+				if (locind == 0)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d location spec missing", arg-start);
+				else {
+					arg++; 
+					state=1;
+				}
+			}
+			else {
+				if (locind) { /* need op before number */
+					if (*arg == '&') {
+						data->tests[testind].location[locind].nextop = IPT_U32_AND;
+					}
+					else if (*arg == '<') {
+						arg++;
+						if (*arg != '<')
+							exit_error(PARAMETER_PROBLEM,
+								   "u32: at char %d a second < expected", arg-start);
+						data->tests[testind].location[locind].nextop = IPT_U32_LEFTSH;
+					}
+					else if (*arg == '>') {
+						arg++;
+						if (*arg != '>')
+							exit_error(PARAMETER_PROBLEM,
+								   "u32: at char %d a second > expected", arg-start);
+						data->tests[testind].location[locind].nextop = IPT_U32_RIGHTSH;
+					}
+					else if (*arg == '@') {
+						data->tests[testind].location[locind].nextop = IPT_U32_AT;
+					}
+					else exit_error(PARAMETER_PROBLEM,
+							"u32: at char %d operator expected", arg-start);
+					arg++;
+				}
+				/* now a number; string_to_number skips white space? */
+				data->tests[testind].location[locind].number =
+					parse_number(&arg, arg-start);
+				locind++;
+				if (locind > U32MAXSIZE)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d too many operators", arg-start);
+			}
+		}
+		else {
+			/* state 1 - reading values: read a range if nothing read yet,
+			   otherwise either ,range or && to end test spec */
+			if (*arg == '&') {
+				arg++;
+				if (*arg != '&')
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d a second & expected", arg-start);
+				if (valind == 0)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d value spec missing", arg-start);
+				else {
+					data->tests[testind].nnums = locind;
+					data->tests[testind].nvalues = valind;
+					testind++;
+					if (testind > U32MAXSIZE)
+						exit_error(PARAMETER_PROBLEM,
+							   "u32: at char %d too many &&'s", arg-start);
+					arg++; state=0; locind=0; valind=0;
+				}
+			}
+			else { /* read value range */
+				if (valind) { /* need , before number */
+					if (*arg != ',')
+						exit_error(PARAMETER_PROBLEM,
+							   "u32: at char %d expected , or &&", arg-start);
+					arg++;
+				}
+				data->tests[testind].value[valind].min = parse_number(&arg, arg-start);
+				while (isspace(*arg)) 
+					arg++;  /* another place white space could be */
+				if (*arg==':') {
+					arg++;
+					data->tests[testind].value[valind].max
+						= parse_number(&arg, arg-start);
+				}
+				else data->tests[testind].value[valind].max
+					     = data->tests[testind].value[valind].min;
+				valind++;
+				if (valind > U32MAXSIZE)
+					exit_error(PARAMETER_PROBLEM,
+						   "u32: at char %d too many ,'s", arg-start);
+			}
+		}
+	}
+}
+
+/* Final check; must specify something. */
+static void
+final_check(unsigned int flags)
+{
+}
+
+/* Prints out the matchinfo. */
+static void
+print(const struct ipt_ip *ip,
+      const struct ipt_entry_match *match,
+      int numeric)
+{
+	printf("u32 ");
+	print_u32((struct ipt_u32 *)match->data);
+}
+
+/* Saves the union ipt_matchinfo in parsable form to stdout. */
+static void save(const struct ipt_ip *ip, const struct ipt_entry_match *match)
+{
+	printf("--u32 ");
+	print_u32((struct ipt_u32 *)match->data);
+}
+
+struct iptables_match u32 = {
+	.next		= NULL,
+	.name		= "u32",
+	.version	= IPTABLES_VERSION,
+	.size		= IPT_ALIGN(sizeof(struct ipt_u32)),
+	.userspacesize	= IPT_ALIGN(sizeof(struct ipt_u32)),
+	.help		= &help,
+	.parse		= &parse,
+	.final_check	= &final_check,
+	.print		= &print,
+	.save		= &save,
+	.extra_opts	= opts
+};
+
+void
+_init(void)
+{
+	register_match(&u32);
+}
diff -urN iptables-1.3.8/extensions/libipt_u32.man iptables/extensions/libipt_u32.man
--- iptables-1.3.8/extensions/libipt_u32.man	1970-01-01 01:00:00.000000000 +0100
+++ iptables/extensions/libipt_u32.man	2006-12-12 11:34:45.000000000 +0100
@@ -0,0 +1,8 @@
+U32 allows you to extract quantities of up to 4 bytes from a packet,
+AND them with specified masks, shift them by specified amounts and
+test whether the results are in any of a set of specified ranges.
+The specification of what to extract is general enough to skip over
+headers with lengths stored in the packet, as in IP or TCP header
+lengths.
+
+Details and examples are in the kernel module source.
