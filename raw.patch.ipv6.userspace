diff -urN --exclude-from=/usr/src/diff.exclude-raw extensions.orig/.TRACE-test6 extensions/.TRACE-test6
--- userspace/extensions.orig/.TRACE-test6	Thu Jan  1 01:00:00 1970
+++ userspace/extensions/.TRACE-test6	Fri Jul 19 09:55:42 2002
@@ -0,0 +1,2 @@
+#! /bin/sh
+[ -f $KERNEL_DIR/net/ipv6/netfilter/ip6t_TRACE.c ] && echo TRACE
diff -urN --exclude-from=/usr/src/diff.exclude-raw extensions.orig/libip6t_TRACE.c extensions/libip6t_TRACE.c
--- userspace/extensions.orig/libip6t_TRACE.c	Thu Jan  1 01:00:00 1970
+++ userspace/extensions/libip6t_TRACE.c	Fri Jul 19 10:01:17 2002
@@ -0,0 +1,63 @@
+/* Shared library add-on to iptables to add TRACE target support. */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <getopt.h>
+
+#include <ip6tables.h>
+#include <linux/netfilter_ipv6/ip6_tables.h>
+
+/* Function which prints out usage message. */
+static void
+help(void)
+{
+	printf(
+"TRACE target v%s takes no options\n",
+IPTABLES_VERSION);
+}
+
+static struct option opts[] = {
+	{ 0 }
+};
+
+/* Initialize the target. */
+static void
+init(struct ip6t_entry_target *t, unsigned int *nfcache)
+{
+}
+
+/* Function which parses command options; returns true if it
+   ate an option */
+static int
+parse(int c, char **argv, int invert, unsigned int *flags,
+      const struct ip6t_entry *entry,
+      struct ip6t_entry_target **target)
+{
+	return 0;
+}
+
+static void
+final_check(unsigned int flags)
+{
+}
+
+static
+struct ip6tables_target trace
+= { NULL,
+    "TRACE",
+    IPTABLES_VERSION,
+    IP6T_ALIGN(0),
+    IP6T_ALIGN(0),
+    &help,
+    &init,
+    &parse,
+    &final_check,
+    NULL, /* print */
+    NULL, /* save */
+    opts
+};
+
+void _init(void)
+{
+	register_target6(&trace);
+}
diff -urN --exclude-from=/usr/src/diff.exclude-raw libiptc.orig/libip6tc.c libiptc/libip6tc.c
--- userspace/libiptc.orig/libip6tc.c	Thu Feb 14 00:13:23 2002
+++ userspace/libiptc/libip6tc.c	Fri Jul 19 09:55:42 2002
@@ -381,6 +381,19 @@
 			assert(h->info.hook_entry[NF_IP6_POST_ROUTING] == n);
 			user_offset = h->info.hook_entry[NF_IP6_POST_ROUTING];
 		}
+	} else if (strcmp(h->info.name, "raw") == 0) {
+		assert(h->info.valid_hooks
+		       == (1 << NF_IP6_PRE_ROUTING
+			   | 1 << NF_IP6_LOCAL_OUT));
+
+		/* Hooks should be first three */
+		assert(h->info.hook_entry[NF_IP6_PRE_ROUTING] == 0);
+
+		n = get_chain_end(h, n);
+		n += get_entry(h, n)->next_offset;
+		assert(h->info.hook_entry[NF_IP6_LOCAL_OUT] == n);
+
+		user_offset = h->info.hook_entry[NF_IP6_LOCAL_OUT];
 	} else {
                 fprintf(stderr, "Unknown table `%s'\n", h->info.name);
 		abort();
