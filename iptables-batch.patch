diff -urN iptables-1.4.1.1.orig/ip6tables-multi.c iptables-1.4.1.1/ip6tables-multi.c
--- iptables-1.4.1.1.orig/ip6tables-multi.c	2008-06-16 15:12:40.000000000 +0200
+++ iptables-1.4.1.1/ip6tables-multi.c	2008-08-24 10:39:07.000000000 +0200
@@ -24,6 +24,9 @@
     
     if (!strcmp(progname, "ip6tables-restore"))
       return ip6tables_restore_main(argc, argv);
+
+    if (!strcmp(progname, "ip6tables-batch"))
+      return ip6tables_batch_main(argc, argv);
     
     fprintf(stderr, "ip6tables multi-purpose version: unknown applet name %s\n", progname);
     exit(1);
diff -urN iptables-1.4.1.1.orig/ip6tables-multi.h iptables-1.4.1.1/ip6tables-multi.h
--- iptables-1.4.1.1.orig/ip6tables-multi.h	2008-06-16 15:12:40.000000000 +0200
+++ iptables-1.4.1.1/ip6tables-multi.h	2008-08-24 10:39:07.000000000 +0200
@@ -4,5 +4,6 @@
 extern int ip6tables_main(int, char **);
 extern int ip6tables_save_main(int, char **);
 extern int ip6tables_restore_main(int, char **);
+extern int ip6tables_batch_main(int, char **);
 
 #endif /* _IP6TABLES_MULTI_H */
diff -urN iptables-1.4.1.1.orig/iptables-batch.c iptables-1.4.1.1/iptables-batch.c
--- iptables-1.4.1.1.orig/iptables-batch.c	1970-01-01 01:00:00.000000000 +0100
+++ iptables-1.4.1.1/iptables-batch.c	2008-08-24 10:42:00.000000000 +0200
@@ -0,0 +1,475 @@
+/*
+ * Author: Ludwig Nussel <ludwig.nussel@suse.de>
+ *
+ * Based on the ipchains code by Paul Russell and Michael Neuling
+ *
+ * (C) 2000-2002 by the netfilter coreteam <coreteam@netfilter.org>:
+ * 		    Paul 'Rusty' Russell <rusty@rustcorp.com.au>
+ * 		    Marc Boucher <marc+nf@mbsi.ca>
+ * 		    James Morris <jmorris@intercode.com.au>
+ * 		    Harald Welte <laforge@gnumonks.org>
+ * 		    Jozsef Kadlecsik <kadlec@blackhole.kfki.hu>
+ *
+ *	iptables-batch -- iptables batch processor
+ *
+ *	See the accompanying manual page iptables(8) for information
+ *	about proper usage of this program.
+ *
+ *	This program is free software; you can redistribute it and/or modify
+ *	it under the terms of the GNU General Public License as published by
+ *	the Free Software Foundation; either version 2 of the License, or
+ *	(at your option) any later version.
+ *
+ *	This program is distributed in the hope that it will be useful,
+ *	but WITHOUT ANY WARRANTY; without even the implied warranty of
+ *	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ *	GNU General Public License for more details.
+ *
+ *	You should have received a copy of the GNU General Public License
+ *	along with this program; if not, write to the Free Software
+ *	Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
+ */
+
+#define _GNU_SOURCE
+#include <stdio.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <errno.h>
+#include <string.h>
+
+#ifdef BATCH_IPV6
+#include <ip6tables.h>
+#include "ip6tables-multi.h"
+#else
+#include <iptables.h>
+#include "iptables-multi.h"
+#endif
+
+static char* errstr = NULL;
+
+static unsigned current_line = 0;
+
+static char*
+skipspace(char* ptr)
+{
+	while(*ptr && isspace(*ptr))
+		++ptr;
+	return ptr;
+}
+
+static char*
+getliteral(char** ptr)
+{
+	char* start = *ptr;
+	char* p = start;
+
+	while(*p && !isspace(*p))
+		++p;
+
+	if(*p)
+	{
+		*p = '\0';
+		++p;
+	}
+
+	*ptr = p;
+	return start;
+}
+
+static char*
+getstring(char** ptr)
+{
+	char* start = *ptr+1; // skip leading "
+	char* p = start;
+	char* o = start;
+	int backslash = 0;
+	int done = 0;
+
+	while(*p && !done)
+	{
+		if(backslash)
+		{
+			backslash = 0;
+			// no escapes supported, just eat the backslash
+			*o++ = *p++;
+		}
+		else if(*p == '\\')
+		{
+			backslash = 1;
+			p++;
+		}
+		else if(*p == '"')
+		{
+			done = 1;
+		}
+		else
+		{
+			*o++ = *p++;
+		}
+	}
+
+	if(done)
+	{
+		*o = '\0';
+		*p = '\0';
+		++p;
+		*ptr = p;
+	}
+	else
+	{
+		errstr = "missing \" at end of string";
+		start = NULL;
+	}
+	return start;
+}
+
+// this is just a very basic method, not 100% shell compatible
+static char*
+getword(char** ptr)
+{
+	*ptr = skipspace(*ptr);
+	if(**ptr == '"')
+		return getstring(ptr);
+	return getliteral(ptr);
+}
+
+// destructive
+static int
+tokenize(int* argc, char* argv[], size_t nargvsize, char* line)
+{
+	char* ptr = skipspace(line);
+	int ret = 0;
+	char* word;
+
+	while(ptr && *ptr)
+	{
+		if(*ptr == '#')
+			break;
+		if(*argc >= nargvsize)
+		{
+			errstr = "too many arguments";
+			ret = -1;
+			break;
+		}
+		word = getword(&ptr);
+		if(!word)
+		{
+			ret = -1;
+			break;
+		}
+		argv[(*argc)++] = word;
+		++ret;
+	}
+	return ret;
+}
+
+#ifdef DEBUG
+static void
+dumpargv(int argc, char* argv[])
+{
+	int i;
+	for(i=0; i < argc; ++i)
+	{
+		printf("%s\"%s\"",i?" ":"", argv[i]);
+	}
+	puts("");
+}
+#endif
+
+struct table_handle
+{
+	char* name;
+#ifdef BATCH_IPV6
+	struct ip6tc_handle *handle;
+#else
+	struct iptc_handle *handle;
+#endif
+};
+
+static struct table_handle* tables = NULL;
+static unsigned num_tables;
+struct table_handle* current_table;
+
+static void
+alloc_tables()
+{
+	tables = realloc(tables, sizeof(struct table_handle) * num_tables);
+}
+
+static void
+set_current_table(const char* name)
+{
+	unsigned i;
+
+	if(!strcmp(name, current_table->name)) // same as last time?
+		return;
+
+	for(i = 0; i < num_tables; ++i) // find already known table
+	{
+		if(!strcmp(name, tables[i].name))
+		{
+			current_table = &tables[i];
+			return;
+		}
+	}
+
+	// table name not known, create new
+	i = num_tables++;
+	alloc_tables();
+	current_table = &tables[i];
+	current_table->name = strdup(name);
+	current_table->handle = NULL;
+}
+
+static int
+find_table(int argc, char* argv[])
+{
+	int i;
+	for(i = 0; i < argc; ++i)
+	{
+		if(!strcmp(argv[i], "-t") || !strcmp(argv[i], "--table"))
+		{
+			++i;
+			if(i >= argc)
+			{
+				fprintf(stderr, "line %d: missing table name after %s\n",
+						current_line, argv[i]);
+				return 0;
+			}
+			set_current_table(argv[i]);
+			return 1;
+		}
+	}
+
+	// no -t specified
+	set_current_table("filter");
+
+	return 1;
+}
+
+static int
+do_iptables(int argc, char* argv[])
+{
+	char *table = "filter";
+	int ret = 0;
+
+	if(!find_table(argc, argv))
+		return 0;
+
+#ifdef BATCH_IPV6
+	ret = do_command6(argc, argv, &table, &current_table->handle);
+
+	if (!ret)
+	{
+		fprintf(stderr, "line %d: %s\n", current_line, ip6tc_strerror(errno));
+	}
+	else
+	{
+		if(!table || strcmp(table, current_table->name))
+		{
+			fprintf(stderr, "line %d: expected table %s, got %s\n",
+					current_line, current_table->name, table);
+			exit(1);
+		}
+	}
+#else
+	ret = do_command(argc, argv, &table, &current_table->handle);
+
+	if (!ret)
+	{
+		fprintf(stderr, "line %d: %s\n", current_line, iptc_strerror(errno));
+	}
+	else
+	{
+		if(!table || strcmp(table, current_table->name))
+		{
+			fprintf(stderr, "line %d: expected table %s, got %s\n",
+					current_line, current_table->name, table);
+			exit(1);
+		}
+	}
+#endif
+
+	return ret;
+}
+
+static int
+do_commit()
+{
+	unsigned i;
+	int ret = 1;
+
+	for(i = 0; i < num_tables; ++i)
+	{
+		if(tables[i].handle)
+		{
+#ifdef BATCH_IPV6
+			if(!ip6tc_commit(tables[i].handle))
+			{
+				fprintf(stderr, "commit failed on table %s: %s\n", tables[i].name, ip6tc_strerror(errno));
+				ret = 0;
+			}
+#else
+			if(!iptc_commit(tables[i].handle))
+			{
+				fprintf(stderr, "commit failed on table %s: %s\n", tables[i].name, iptc_strerror(errno));
+				ret = 0;
+			}
+#endif
+		}
+	}
+
+	return ret;
+}
+
+static void
+help()
+{
+#ifdef BATCH_IPV6
+	fprintf(stderr, "Usage: %s [FILE]\n\n", ip6tables_globals.program_name);
+#else
+	fprintf(stderr, "Usage: %s [FILE]\n\n", iptables_globals.program_name);
+#endif
+	puts("Read iptables commands from FILE, commit them at EOF\n");
+	puts("In addition to normal iptables calls the commands");
+	puts("'commit' and 'exit' are understood.");
+	exit(0);
+}
+
+#if defined(IPTABLES_MULTI) && defined(BATCH_IPV4)
+int
+iptables_batch_main(int argc, char *argv[])
+#elif defined(IPTABLES_MULTI) && defined(BATCH_IPV6)
+int
+ip6tables_batch_main(int argc, char *argv[])
+#else
+int
+main(int argc, char *argv[])
+#endif
+{
+	int ret = 1;
+	int numtok;
+	size_t llen = 0;
+	char* line = NULL;
+	ssize_t r = -1;
+	int nargc = 0;
+	char* nargv[256];
+	FILE* fp = stdin;
+
+#ifdef BATCH_IPV6
+	ip6tables_globals.program_name = "ip6tables-batch";
+	ret = xtables_init_all(&ip6tables_globals, NFPROTO_IPV6);
+	if (ret < 0) {
+		fprintf(stderr, "%s/%s Failed to initialize xtables\n",
+				ip6tables_globals.program_name,
+				ip6tables_globals.program_version);
+		exit(1);
+	}
+#else
+	iptables_globals.program_name = "iptables-batch";
+	ret = xtables_init_all(&iptables_globals, NFPROTO_IPV4);
+	if (ret < 0) {
+		fprintf(stderr, "%s/%s Failed to initialize xtables\n",
+			iptables_globals.program_name,
+			iptables_globals.program_version);
+		exit(1);
+	}
+
+#endif
+	//program_version = XTABLES_VERSION;
+
+#ifdef NO_SHARED_LIBS
+	init_extensions();
+#endif
+	if(argc > 1)
+	{
+		if(strcmp(argv[1], "--help") || strcmp(argv[1], "-h"))
+		{
+			help();
+		}
+		else if(strcmp(argv[1], "-"))
+		{
+			fp = fopen(argv[1], "r");
+			if(!fp)
+			{
+				perror("fopen");
+				exit(1);
+			}
+		}
+	}
+
+	num_tables = 4;
+	alloc_tables();
+	tables[0].name = "filter";
+	tables[0].handle = NULL;
+	tables[1].name = "mangle";
+	tables[1].handle = NULL;
+	tables[2].name = "nat";
+	tables[2].handle = NULL;
+	tables[3].name = "raw";
+	tables[3].handle = NULL;
+	current_table = &tables[0];
+
+	while((r = getline(&line, &llen, fp)) != -1)
+	{
+		if(llen < 1 || !*line)
+			continue;
+		if(line[strlen(line)-1] == '\n')
+			line[strlen(line) -1 ] = '\0';
+
+		++current_line;
+		nargc = 0;
+		errstr = NULL;
+		numtok = tokenize(&nargc, nargv, (sizeof(nargv)/sizeof(nargv[0])), line);
+		if(numtok == -1)
+		{
+		}
+		else if (numtok == 0)
+		{
+			continue;
+		}
+		else if(nargc < 1)
+		{
+			errstr = "insufficient number of arguments";
+		}
+
+		if(errstr)
+		{
+			fprintf(stderr, "parse error in line %d: %s\n", current_line, errstr);
+			ret = 0;
+			break;
+		}
+
+#ifdef DEBUG
+		dumpargv(nargc, nargv);
+#endif
+
+#ifdef BATCH_IPV6
+		if(!strcmp(nargv[0], "ip6tables"))
+#else
+		if(!strcmp(nargv[0], "iptables"))
+#endif
+		{
+			ret = do_iptables(nargc, nargv);
+			if(!ret) break;
+		}
+		else if(!strcmp(nargv[0], "exit"))
+		{
+			break;
+		}
+		else if(!strcmp(nargv[0], "commit"))
+		{
+			ret = do_commit();
+			if(!ret) break;
+		}
+		else
+		{
+			fprintf(stderr, "line %d: invalid command '%s'\n", current_line, nargv[0]);
+		}
+	}
+
+	if(ret)
+		ret = do_commit();
+
+	exit(!ret);
+}
diff -urN iptables-1.4.1.1.orig/iptables-multi.c iptables-1.4.1.1/iptables-multi.c
--- iptables-1.4.1.1.orig/iptables-multi.c	2008-06-16 15:12:40.000000000 +0200
+++ iptables-1.4.1.1/iptables-multi.c	2008-08-24 10:39:07.000000000 +0200
@@ -28,6 +28,9 @@
     
     if (!strcmp(progname, "iptables-xml"))
       return iptables_xml_main(argc, argv);
+
+    if (!strcmp(progname, "iptables-batch"))
+      return iptables_batch_main(argc, argv);
     
     fprintf(stderr, "iptables multi-purpose version: unknown applet name %s\n", progname);
     exit(1);
diff -urN iptables-1.4.1.1.orig/iptables-multi.h iptables-1.4.1.1/iptables-multi.h
--- iptables-1.4.1.1.orig/iptables-multi.h	2008-06-16 15:12:40.000000000 +0200
+++ iptables-1.4.1.1/iptables-multi.h	2008-08-24 10:39:07.000000000 +0200
@@ -5,5 +5,6 @@
 extern int iptables_save_main(int, char **);
 extern int iptables_restore_main(int, char **);
 extern int iptables_xml_main(int, char **);
+extern int iptables_batch_main(int, char **);
 
 #endif /* _IPTABLES_MULTI_H */
diff -urN iptables-1.4.1.1.orig/Makefile.am iptables-1.4.1.1/Makefile.am
--- iptables-1.4.3.orig/Makefile.am	2008-06-16 15:12:40.000000000 +0200
+++ iptables-1.4.3/Makefile.am	2008-08-24 10:43:30.000000000 +0200
@@ -31,8 +31,8 @@
 iptables_xml_LDADD        = libxtables.la
 iptables_multi_SOURCES    = iptables-multi.c iptables-save.c \
                             iptables-restore.c iptables-xml.c \
-                            iptables-standalone.c iptables.c
-iptables_multi_CFLAGS     = ${AM_CFLAGS} -DIPTABLES_MULTI
+                            iptables-standalone.c iptables.c iptables-batch.c
+iptables_multi_CFLAGS     = ${AM_CFLAGS} -DIPTABLES_MULTI -DBATCH_IPV4
 iptables_multi_LDFLAGS    = ${iptables_LDFLAGS}
 iptables_multi_LDADD      = ${iptables_LDADD}
 
@@ -44,9 +44,14 @@
 iptables_save_LDFLAGS     = ${iptables_LDFLAGS}
 iptables_save_LDADD       = ${iptables_LDADD}
 
+iptables_batch_SOURCES    = iptables-batch.c iptables.c xtables.c
+iptables_batch_CFLAGS     = ${AM_CFLAGS} -DBATCH_IPV4
+iptables_batch_LDFLAGS    = ${iptables_LDFLAGS}
+iptables_batch_LDADD      = ${iptables_LDADD}
+
 # iptables-multi, semi-static
 iptables_static_SOURCES   = ${iptables_multi_SOURCES} xtables.c
-iptables_static_CFLAGS    = ${iptables_multi_CFLAGS} -DNO_SHARED_LIBS=1
+iptables_static_CFLAGS    = ${iptables_multi_CFLAGS} -DNO_SHARED_LIBS=1 -DBATCH_IPV4
 iptables_static_LDADD     = libiptc/libiptc.la extensions/libext4.a -lm
 
 iptables_xml_SOURCES      = iptables-xml.c
@@ -58,8 +63,8 @@
 
 ip6tables_multi_SOURCES   = ip6tables-multi.c ip6tables-save.c \
                             ip6tables-restore.c ip6tables-standalone.c \
-                            ip6tables.c
-ip6tables_multi_CFLAGS    = ${AM_CFLAGS} -DIPTABLES_MULTI
+                            ip6tables.c iptables-batch.c
+ip6tables_multi_CFLAGS    = ${AM_CFLAGS} -DIPTABLES_MULTI -DBATCH_IPV6
 ip6tables_multi_LDFLAGS   = ${ip6tables_LDFLAGS}
 ip6tables_multi_LDADD     = ${ip6tables_LDADD}
 
@@ -71,9 +76,14 @@
 ip6tables_save_LDFLAGS    = ${ip6tables_LDFLAGS}
 ip6tables_save_LDADD      = ${ip6tables_LDADD}
 
+ip6tables_batch_SOURCES   = iptables-batch.c ip6tables.c xtables.c
+ip6tables_batch_CFLAGS     = ${AM_CFLAGS} -DBATCH_IPV6
+ip6tables_batch_LDFLAGS   = ${ip6tables_LDFLAGS}
+ip6tables_batch_LDADD     = ${ip6tables_LDADD}
+
 # iptables-multi, semi-static
 ip6tables_static_SOURCES    = ${ip6tables_multi_SOURCES} xtables.c
-ip6tables_static_CFLAGS     = ${ip6tables_multi_CFLAGS} -DNO_SHARED_LIBS=1
+ip6tables_static_CFLAGS     = ${ip6tables_multi_CFLAGS} -DNO_SHARED_LIBS=1 -DBATCH_IPV6
 ip6tables_static_LDADD      = libiptc/libiptc.la extensions/libext6.a -lm
 
 bin_PROGRAMS     = iptables-xml
@@ -89,7 +99,8 @@
 endif
 if ENABLE_SHARED
 sbin_PROGRAMS += iptables iptables-multi iptables-restore iptables-save \
-                 ip6tables ip6tables-multi ip6tables-restore ip6tables-save
+                 ip6tables ip6tables-multi ip6tables-restore ip6tables-save \
+                 iptables-batch ip6tables-batch
 endif
 
 iptables.8: ${srcdir}/iptables.8.in extensions/matches4.man extensions/targets4.man
